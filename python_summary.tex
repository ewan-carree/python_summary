\documentclass[a4paper, 12pt, titlepage]{scrartcl} %document type
\usepackage[utf8]{inputenc} %encoding
\usepackage[T1]{fontenc}    
\usepackage[english]{babel} %language

\usepackage{graphicx}

\titlehead{\centering\includegraphics[width=6cm]{python}}
\title{python\_summary}
\author{}
\date{August 14, 2020 - \today}
\publishers{Ewan Carree}

%manage cells in tables
\usepackage{makecell}

%manage colors
\usepackage{xcolor}
%\usepackage{color}

%New colors defined below
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% add code
\usepackage{listings}
%Code listing style named "mystyle"
\lstdefinestyle{mystyle}{
  backgroundcolor=\color{backcolour},   commentstyle=\color{codegray},
  keywordstyle=\color{magenta},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{black},
  basicstyle=\ttfamily\footnotesize,
  breakatwhitespace=false,         
  breaklines=true,                 
  captionpos=b,                    
  keepspaces=true,                 
  numbers=left,                    
  numbersep=5pt,                  
  showspaces=false,                
  showstringspaces=false,
  showtabs=false,                  
  tabsize=4
}
%"mystyle" code listing set
\lstset{style=mystyle}

%\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry} 

%extern and intern links
\usepackage{hyperref} %links
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    urlcolor=blue,
    linktoc=all
}

\iffalse % start ignore code
%Python code highlighting
\begin{lstlisting}[language=Python]

\end{lstlisting} \vspace{5mm}
\fi % end ignore code







\begin{document}

\maketitle
\newpage

This PDF is meant to be a summary of all the knowledge that I've acquired during ENIB. It is also meant to be upgrade each time I learn something new or a new concept. I did it to use it in my whole life as I want to become a software developer.

\vspace{10mm}

Thanks to Corey Schafer, Tech with Tim, Kalle Hallden and Openclassroom because I've learnt everything with them and I've used some of their code into this PDF.

\newpage

\tableofcontents

\newpage
\section{Python reserved words}
In python 3, there are some reserved words that you can't use in your program as variables, function name, class name, ...

\vspace{35mm}

\begin{table}[h]
\begin{center}
{\renewcommand{\arraystretch}{2} %donne la distance entre les lignes%
{\setlength{\tabcolsep}{1.5cm} %donne la distance entre les collones%
\begin{tabular}{|l|c|r|}
  \hline
  \hyperref[subsec:Bool]{False} & \hyperref[subsec:Keyword]{None} & \hyperref[subsec:Bool]{True} \\
  \hline
  \hyperref[subsec:Keyword]{and} & \hyperref[As]{as} & \hyperref[subsec:Assertion]{assert} \\
  \hline
  \hyperref[subsec:BCPR]{break} & \hyperref[sec:Class]{class} & \hyperref[subsec:BCPR]{continue} \\
  \hline
  \hyperref[sec:Function]{def} & \hyperref[Del]{del} & \hyperref[IEE]{elif} \\
  \hline
  \hyperref[subsec:Else]{else} & \hyperref[TEEF]{except} & \hyperref[TEEF]{finally} \\
  \hline
  \hyperref[subsec:For]{for} & \hyperref[subsec:Import]{from} & \hyperref[subsec:Global/Nonlocal]{global} \\
  \hline
  \hyperref[IEE]{if} & \hyperref[subsec:Import]{import} & \hyperref[Comprehension]{in} \\
  \hline
  \hyperref[subsec:Is]{is} & \hyperref[subsec:Lambda]{lambda} & \hyperref[subsec:Global/Nonlocal]{nonlocal} \\
  \hline 
  \hyperref[subsec:Keyword]{not} & \hyperref[subsec:Keyword]{or} & \hyperref[subsec:BCPR]{pass} \\
  \hline 
  \hyperref[Raise]{raise} & \hyperref[subsec:BCPR]{return} & \hyperref[TEEF]{try} \\
  \hline
  \hyperref[subsec:While]{while} & \hyperref[subsec:ContextManager]{with} & \hyperref[subsec:Generators]{yield} \\
  \hline
\end{tabular}}}
\end{center}
\caption{Reserved words}
\end{table}



\clearpage
\section{Types}
Python offers different basics types that are often enough for your program.

\subsection{Immutable}
Immutable means that you can't directly modify your variable after you've assigned it. You have to reassign or create a new variable to work on a previous one

\subsubsection{String}
Python string is an ordered collection of characters which is used to represent and store the text-based information. Strings are stored as individual characters in a contiguous memory location. It can be accessed from both directions: forward and backward. A string can be seen in some ways as a list of characters. \\It's better to use ' for as single character and " for a chain.

\vspace{5mm}

Here are some methods that you can apply on strings (I choose to reassign the variable whenever it's possible) : 
\begin{itemize}
\begin{lstlisting}[language=Python]
string = "Hello, world!"
\end{lstlisting} \vspace{5mm}

\item Upper case \\
Return a string with every single element from the original one in uppercase.
\begin{lstlisting}[language=Python]
string = string.upper()
# HELLO, WORLD!
\end{lstlisting} \vspace{5mm}

\item Lower case \\
Return a string with every single element from the original one in lowercase.
\begin{lstlisting}[language=Python]
string = string.lower()
# hello, world!
\end{lstlisting} \vspace{5mm}

\item Capital \\
Return a string with the first Letter in uppercase and the rest in lowercase.
\begin{lstlisting}[language=Python]
string = string.capitalize()
# Hello, world!
\end{lstlisting} \vspace{5mm}

\item Strip \\
Return a string without the blank spaces from both sides of the original string.
\begin{lstlisting}[language=Python]
string = string.strip()
\end{lstlisting} \vspace{5mm}

\item Find \\
Return an integer which is the position of the first argument found in the string from left to right.
\begin{lstlisting}[language=Python]
position = string.find('l')
# 2
\end{lstlisting} \vspace{5mm}

\item Count \\
Return an integer that represents the number of occurrences of the argument found in the string. 
\begin{lstlisting}[language=Python]
nb = string.count('l')
# 3
\end{lstlisting} \vspace{5mm}

\item Replace \\
Return a string where at least a part of it have been replaced by some another words.
\begin{lstlisting}[language=Python]
string = string.replace("world", "dlrow")
# Hello, dlrow!
\end{lstlisting} \vspace{5mm}

\item Multiply \\
Return a string with n times the original string.
\begin{lstlisting}[language=Python]
string = string*3
# Hello, dlrow!Hello, dlrow!Hello, dlrow!
\end{lstlisting} \vspace{5mm}

\item String to List \\
Transform your string into a list.
\begin{lstlisting}[language=Python]
tableau = string.split(' ')
# ['Hello,', 'dlrow!Hello,', 'dlrow!Hello,', 'dlrow!']
\end{lstlisting} \vspace{5mm}

\item Fill \\
Return a string filled with zero to correspond to have the same digit in every number.
\begin{lstlisting}[language=Python]
string = '5'
string = string.zfill(3)
# 005
\end{lstlisting} \vspace{5mm}

There is another way of doing it while printing argument with \hyperref[subsec:F-string]{F-string}.

\item Encode \\
It's possible to encode a string into bytes using a special string methods. You have to put a b for bytes in front of the first " of you string. Another way is to use encode function as my\_string.encode()
\end{itemize}

\subsubsection{Integer}
You can write very long number in a more readable way with \_ : 
\begin{lstlisting}[language=Python]
nb = 1_000_000
# 1000000
\end{lstlisting} \vspace{5mm}

\subsubsection{Float}
You can handle decimal to choose how many decimal you need. You can modify it by two different ways : 
\begin{lstlisting}[language=Python]
my_float = 3.3333333
print("%.0f" % my_float + "with no decimal and " + "%.2f" % my_float + "with two decimals") #3 with no decimal and 3.33 with two decimals
round(my_float, 3) # 3.333
\end{lstlisting} \vspace{5mm}

There is another way of doing it while printing argument with \hyperref[subsec:F-string]{F-string}.

\subsubsection{Tuple}
A tuple is a container that can contain multiple variables with multiple types that have a link together. 

\begin{itemize}
\item Unpack \\
You can unpack each variable from a tuple very easily in python as follow : \textbf{first\_variable, ..., n\_variable = my\_tuple\_with\_n\_variable}

\begin{lstlisting}[language=Python]
my_tuple = (1,2)

#unpack :
a, b = my_tuple #1 and 2
\end{lstlisting} \vspace{5mm}

\item Ignore unpacked variables \\
When you unpack tuple arguments, sometimes some argument aren't useful, the common way to write it is with \_
\begin{lstlisting}[language=Python]
my_tuple = (1,2)
my_tuple2 = (1,2,3,4,5)

#We don't need b :
a, _ = my_tuple #1

#Another example :
for _ in range(2):
	print("I don't care about i")
#I don't care about i
#I don't care about i

#Another example :
a, b, *_ = my_tuple2 #We ignore everything after the first two variables, the rest is stored in a list.
a, b, *c, d = my_tuple2 
print(f"{a}, {b}, {c}, {d}") #1, 2, [3, 4], 5
\end{lstlisting} \vspace{5mm}

\item Named tuple \\
To name your tuple is a way to create a much more clear code for someone who read your code. For example, an unnamed tuple doesn't give that much information on what it contains.
\begin{lstlisting}[language=Python]
from collections import namedtuple

Color = namedtuple("Color", ["red", "green", "blue"])

white = Color(255,255,255)

print(white.red) # we can also call like basic tuple with white[0]
# 255
\end{lstlisting} \vspace{5mm}
\end{itemize}


\subsubsection{Bool}
\label{subsec:Bool}
There is only two types of Boolean : True and False. 

\vspace{5mm}

Everything can be considered as True if it different from 0 or False. 

\begin{lstlisting}[language=Python]
a = "Salut"
b = 0
if a:
	print("a fonctionne")
	# a fonctionne
else:
	print("a ne fonctionne pas")

if b:
	print("b fonctionne")
else:
	print("b ne fonctionne pas")
	# b ne fonctionne pas
\end{lstlisting} \vspace{5mm}

\subsection{Mutable}
Mutable means that if you are working on a variable, you directly modify it and don't need to create a new variable or reassign the previous one. It can cause conflict if two process are using the same variable that can be changed.

\subsubsection{List}
A list is a container that can contain multiple variables with multiple types that have a link together.

\vspace{5mm}

Here are some methods that you can apply on lists : 

\begin{lstlisting}[language=Python]
tableau = ['Hello,', 'dlrow!Hello,', 'dlrow!Hello,', 'dlrow!']
\end{lstlisting} \vspace{5mm}

\begin{itemize}
\item Add \\
You can merge two lists into single one containing elements from both original lists.
\begin{lstlisting}[language=Python]
new_tab = first_part + second_part
# ['Hello,', 'dlrow!Hello,', 'dlrow!Hello,', 'dlrow!']
\end{lstlisting} \vspace{5mm}

\item Multiply \\
Just like a string, you can multiply your list.
\begin{lstlisting}[language=Python]
multilpied_new_tab = new_tab *3
# ['Hello,', 'dlrow!Hello,', 'dlrow!Hello,', 'dlrow!', 'Hello,', 'dlrow!Hello,', 'dlrow!Hello,', 'dlrow!', 'Hello,', 'dlrow!Hello,', 'dlrow!Hello,', 'dlrow!']
\end{lstlisting} \vspace{5mm}

\item Index \\
Return an integer which correspond to the position of the element searched.
\begin{lstlisting}[language=Python]
position = tableau.index('A')
# 1
\end{lstlisting} \vspace{5mm}

\item Range \\
You can initialize a list of n ascending numbers easily with : 
\begin{lstlisting}[language=Python]
my_list = list(range(n))
\end{lstlisting} \vspace{5mm}

\item List to String \\
Transfrom your list into a string.
\begin{lstlisting}[language=Python]
string = ' '.join(tableau)
# Hello, A dlrow!Hello, dlrow!Hello, dlrow!
\end{lstlisting} \vspace{5mm}

\item Sort \\
\label{Sort}
You can easily sort your lists in python with \textbf{my\_list.sort(key, reverse = False)}. You have the possibility to add parameters into these functions with a \textit{key} to specify what you want to sort and \textit{reverse} to sort in the opposite order. The key can be a function, a lambda function or a type if it is possible to cast each element in this type.

\begin{lstlisting}[language=Python]
cars = ['Ford', 'BMW', 'Volvo']

cars.sort(reverse=True) # ['Volvo', 'Ford', 'BMW']

cars.sort(key = len) # ['BMW', 'Ford', 'Volvo'] #upper case matter

cars.sort(reverse = True, key = lambda x: x[::-1]) # ['Volvo', 'Ford', 'BMW']
\end{lstlisting} \vspace{5mm}
\end{itemize}

\subsubsection{Dict}
A dict is an non-organized container that have variables associated to keys to recognize them. Keys are offently strings but we can also use integers.

\vspace{5mm}

Here are some methods that you can apply on dicts : 
\begin{lstlisting}[language=Python]
dictionnaire = {"nom":"Jerome", "age":20}
\end{lstlisting} \vspace{5mm}

\begin{itemize}
\item Keys \\
Return a (dict)list containing every keys that are into you dictionnary.
\begin{lstlisting}[language=Python]
keys = dictionnaire.keys()
#dict_keys(['nom', 'age'])
\end{lstlisting} \vspace{5mm}

\item Values \\
Return a (dict)list containing every values that are into you dictionnary.
\begin{lstlisting}[language=Python]
keys = dictionnaire.keys()
#dict_values(['Jerome', 20])
\end{lstlisting} \vspace{5mm}

\item Items \\
Return a (dict)tuple containing every keys associated to their values that are into you dictionnary.
\begin{lstlisting}[language=Python]
both = dictionnaire.items()
# dict_items([('nom', 'Jerome'), ('age', 20)])
\end{lstlisting} \vspace{5mm}
\item Merge two dicts \\
You are able to merge two dicts in a single one. If some keys are repeated, it's the last one that is gonna overwrite.
\begin{lstlisting}[language=Python]
x = {'a':1, 'b':2}
y = {'c':3, 'a':4}
z = {**x,**y} # {'c':3, 'b':2, 'a':4}
\end{lstlisting} \vspace{5mm}
\end{itemize}


\subsubsection{Set}
A set is a container that are very useful for mathematical operations.\\
It is similar to a list except the fact that there is only unique value in a set.
\begin{lstlisting}[language=Python]
my_list = [1,1,3,5,5]
my_set = set(my_list) # {1, 3, 5}
\end{lstlisting} \vspace{5mm}

Here are some methods that you can apply on sets : 
\begin{lstlisting}[language=Python]
my_set = {1,2} # impossible to init with {} because it's a dict but possible with set()
\end{lstlisting} \vspace{5mm}

\begin{itemize}
\item Add \\
Add allows us to add one single value to our set.
\begin{lstlisting}[language=Python]
my_set.add(3) # {1,2,3} 
\end{lstlisting} \vspace{5mm}

\item Update \\
Update allows us to add multiple values to our set. We can pass many arguments into the update() function like lists, other sets, ...
\begin{lstlisting}[language=Python]
my_set.update([4,5]) # {1,2,3,4,5}
\end{lstlisting} \vspace{5mm}

\item Remove \\
Remove allows us to remove one single value from our set. If the value doesn't exist, then it raises an error.
\begin{lstlisting}[language=Python]
my_set.remove(5) # {1,2,3,4}
\end{lstlisting} \vspace{5mm}

\item Discard \\
Discard allows us to remove one single value from our set. If the value doesn't exist, then it dosen't do anything. 
\begin{lstlisting}[language=Python]
my_set.discard(5) # {1,2,3,4}
\end{lstlisting} \vspace{5mm}

\item Pop \\
Pop allows us to remove one single element from our set but we don't know which one because sets are unordered data type, it's completely arbitrary.
\begin{lstlisting}[language=Python]
my_set.pop() # {1,3,4}
\end{lstlisting} \vspace{5mm}

\item Clear \\
Clear allows us to remove every item from our set.
\begin{lstlisting}[language=Python]
my_set.clear() # set()
\end{lstlisting} \vspace{5mm}
\end{itemize} \vspace{5mm}

As said before, sets are also very useful for math methods, here are some exemples of what we can do with them :

\begin{table}[h]
\begin{center}
{\renewcommand{\arraystretch}{2} %donne la distance entre les lignes%
{\setlength{\tabcolsep}{1.5cm} %donne la distance entre les collones%
\begin{tabular}{|c|c|}
  \hline
  \makecell{\makecell{ | \\ union()} \\ Union} & \makecell{\makecell{ \& \\ intersection()} \\ Intersection} \\
  \hline
  \makecell{\makecell{ - \\ difference()} \\ Difference} & \makecell{\makecell{ $\land$ \\ symmetric\_difference()} \\ Symmetric difference} \\
  \hline
\end{tabular}}}
\end{center}
\caption{Sets operations}
\end{table} \vspace{5mm}



\begin{lstlisting}[language=Python]
A = {1, 2, 3, 4, 5}
B = {4, 5, 6, 7, 8}
\end{lstlisting} \vspace{5mm}
\begin{itemize}
    \item Union \\
    Union of A and B is a set of all elements from both sets.
    \begin{lstlisting}[language=Python]
    A.union(B) # {1, 2, 3, 4, 5, 6, 7, 8}
    print(A | B) # {1, 2, 3, 4, 5, 6, 7, 8}\end{lstlisting} \vspace{5mm}
    
    \item Intersection \\
    Intersection of A and B is a set of elements that are common in both the sets.
    \begin{lstlisting}[language=Python]
    A.intersection(B) # {4, 5}
    print(A & B) # {4, 5}\end{lstlisting} \vspace{5mm}
    
    \item Difference \\
    Difference of the set B from set A(A - B) is a set of elements that are only in A but not in B. Similarly, B - A is a set of elements in B but not in A.
    \begin{lstlisting}[language=Python]
    A.difference(B) # {1, 2, 3}
    print(A - B) # {1, 2, 3}\end{lstlisting} \vspace{5mm}
    
    \item Symmetric difference \\
    Symmetric Difference of A and B is a set of elements in A and B but not in both (excluding the intersection).
    \begin{lstlisting}[language=Python]
    A.symmetric_difference(B) # {1, 2, 3, 6, 7, 8}
    print(A ^ B) # {1, 2, 3, 6, 7, 8}\end{lstlisting} \vspace{5mm}
    
\end{itemize}

\section{Containers}
Containers are any object that holds an arbitrary number of other objects. Generally, containers provide a way to access the contained objects and to iterate over them. We can find lists, strings, dicts, tuples and sets. Look out for mutability / immutability, some methods aren't possible between each other. 

\subsection{Comprehension}
\label{Comprehension}
Comprehension is probably one of the most powerful method in python. It conbines map and filter function into a single method. \textbf{[func\_to\_apply() for elem in container if filter\_condition]} 

\subsubsection{List}
Example with lists :
\begin{lstlisting}[language=Python]
my_list = [1,2,3]
new_list = [x**x for x in my_list if x%2!=0]

#before : [1, 2, 3] and now : [1, 27]
\end{lstlisting}\vspace{5mm}

\subsubsection{Dict}
Example with dicts :
\begin{lstlisting}[language=Python]
names = ["Peter Parker", "Clark Kent", "Wade Wilson", "Bruce Wayne"]
heroes = ["Spiderman", "Superman", "Deadpool", "Batman"]

my_dict = {name: hero for name, hero in zip(names, heroes) if name != "Peter Parker"}
# {'Clark Kent': 'Superman', 'Wade Wilson': 'Deadpool', 'Bruce Wayne': 'Batman'}
\end{lstlisting} \vspace{5mm}

\subsubsection{Set}
Example with sets :
\begin{lstlisting}[language=Python]
my_list = [1,1,3,5,5]
my_set = {n for n in my_list} #{1,3,5}
\end{lstlisting} \vspace{5mm}

\subsubsection{Generator}
You can also use generator as comprehension like with list to save memory and time simply by replacing the \textbf{[]} from list comprehension with \textbf{()} for generator comprehension. \\
Here : 
\begin{lstlisting}[language=Python]
my_nums = [x*x for x in [1,2,3,4,5]]
print(my_nums) # [1, 4, 9, 16, 25]
\end{lstlisting} \vspace{5mm}

Become : 
\begin{lstlisting}[language=Python]
my_nums = (x*x for x in [1,2,3,4,5])
for num in my_nums:
    print(num)
# 1
# 4
# 9
# 16
# 25
\end{lstlisting} \vspace{5mm}

\subsection{Slicing}
Slicing is a method that concerns containers, you can use slicing on every possible container. \textbf{[start:end:step]} \textit{end argument isn't take in account : [start:end[}

\subsubsection{Last element} 
If you don't know the length of a certain container, you can access to the last element with slicing.
\begin{lstlisting}[language=Python]
dernier_elem = tableau[-1]
# dlrow!
\end{lstlisting} \vspace{5mm}

\subsubsection{Trunc} 
You can also trunc your mutable container to keep just what you need.
\begin{lstlisting}[language=Python]
first_part = tableau[:3]
second_part = tableau[3:]
# first_part : ['Hello,', 'dlrow!Hello,', 'dlrow!Hello,'] and second_part : ['dlrow!']
\end{lstlisting} \vspace{5mm}

\subsubsection{Insert}  
If you need to precisely insert an element into mutable container, slicing is a good way of doing it.
\begin{lstlisting}[language=Python]
tableau[1:1] = 'A'
# ['Hello,', 'A', 'dlrow!Hello,', 'dlrow!Hello,', 'dlrow!']
\end{lstlisting} \vspace{5mm}

\subsubsection{Reverse} 
If you need to reverse your mutable container you can also use slicing.
\begin{lstlisting}[language=Python]
tableau[::-1]
# ['dlrow!', 'dlrow!Hello,', 'dlrow!Hello,'; 'A', 'Hello,']
\end{lstlisting} \vspace{5mm}

\subsection{Sort}
You can sort your container if they contains comparable elements with a powerful method in python. \textbf{sorted(my\_container, key, reverse = False)}. Sorted return a new list so you might have to cast it later. You have the possibility to add parameters into these functions with a \textit{key} to specify what you want to sort and \textit{reverse} to sort in the opposite order. The key can be a function, a lambda function or a type if it is possible to cast each element in this type.

\vspace{5mm}

There is a more powerful way to do all these methods with \hyperref[subsec:Operator]{\textbf{operator}} module.

\subsubsection{List}
You can use sorted on list the same way we've seen with \hyperref[Sort]{\textbf{sort}}.

\subsubsection{String}
String sorting is based on ASCII table, upper or lower case matter.

\begin{lstlisting}[language=Python]
string_value = 'I like to sort'
sorted_string = sorted(string_value.split()) #['I', 'like', 'sort', 'to'] #split() allows to not consider white spaces
\end{lstlisting} \vspace{5mm}

\subsubsection{Dict}
\begin{lstlisting}[language=Python]
my_dict = {1: 2, 2: -10, "Hello": 1234}

my_sorted_dict = sorted(my_dict.items(), key = lambda item: item[1]) # [(2,-10),(1,2),("hello",1234)]
\end{lstlisting} \vspace{5mm}

\subsubsection{Set}
Here is an example with a type as key argument, it useful in this case because we don't really want to sort those elements as strings, but as numbers.

\begin{lstlisting}[language=Python]
my_set = {'0','4','1','10'}
my_sorted_set = sorted(my_set) # ['0', '1', '10', '4']

my_good_sorted_set = sorted(my_set, key = int) # ['0', '1', '4', '10']
\end{lstlisting} \vspace{5mm}

\subsection{Empty}
Sometimes you need to know if a container is empty. There are two common ways to do it :
\begin{lstlisting}[language=Python]
if not my_container:
    print("empty")

if len(my_container)==0:
    print("empty")
\end{lstlisting} \vspace{5mm}


\newpage
\section{Function}
\label{sec:Function}
A function is a block of organized, reusable code that is used to perform a single, related action. Functions provide better modularity for your application and a high degree of code reusing.

\subsection{Lambda function}
\label{subsec:Lambda}
Lambda function are very small function, it's very simple to create them and very often better than a function. \textbf{function\_name = lambda parameter : return\_value}
\begin{lstlisting}[language=Python]
def equivalent_lambda(x):
	return x+5
	
real_lambda = lambda x : x+5

# equivalent_lambda : 10 and real_lambda : 10
\end{lstlisting} \vspace{5mm}

\subsection{Default argument}
Default parameters are used for arguments that don't necessarily need a value. We assign a default value that can be overloaded if needed. Default arguments are always declared after non-default arguments into function's head. \textbf{def func(non\_default\_arguments, \textit{default\_arguments = value})}

\begin{lstlisting}[language=Python]
def func(age, nom="Jerome"):
	print(f"Tu as {age} ans et tu t'appelles {nom}")

func(20, "Antoine")
func(20)
# Tu as 20 ans et tu t'appelles Antoine
# Tu as 20 ans et tu t'appelles Jerome
\end{lstlisting} \vspace{5mm}

\textbf{Warning} : A default argument is evaluated only once time when the function is called for the first time. When you repeat function calls, it may cause problems especially with mutable arguments like lists. If your default argument is an empty list, it will create this empty list one time and reuse it for next calls. The way to counter this problem is to put an immutable argument and then create the list inside the function. \\
Here is an example : 
\begin{lstlisting}[language=Python]
def add_employee(emp, emp_list = []):
    emp_list.append(emp)
    print(emp_list) # Not good because emp_list is mutable and is reused each time this function is called.
\end{lstlisting} \vspace{5mm}
Will become :
\begin{lstlisting}[language=Python]
def add_employee(emp, emp_list = None):
    if emp_list is None:
        emp_list = []
    emp_list.append(emp)
    print(emp_list) # Good because emp_list is immutable and is new each time this function is called.
\end{lstlisting} \vspace{5mm}

\subsection{Unknown arguments}
Sometimes you don't know how many arguments a function is going to receive. Also, it's important to handle unknown arguments. \textit{It's the case for exemple with the print() function}. \textbf{* means unnamed arguments and ** means named arguments}
\begin{lstlisting}[language=Python]
def parameters(*args, **kwargs):
	print(f"I received these unnamed args : {args}")
	print(f"I received these named args : {kwargs}")
parameters(1,"azerty",[1,2], couleur="rouge", taille_en_cm=172)
both
# I received these unnamed args : (1, 'azerty', [1, 2])
# I received these named args : {'couleur': 'rouge', 'taille_en_cm': 172}
\end{lstlisting} \vspace{5mm}

\subsection{Map function}
Map function is a special function used to apply a function for each element of a container. \textbf{map(function\_to\_apply, list)}
\begin{lstlisting}[language=Python]
liste = [1,2,3]
def map_function(x):
	return x**x
mapped_list = list(map(map_function,liste)) #No () for argument function

# before : [1, 2, 3] and now : [1, 4, 27]
\end{lstlisting} \vspace{5mm}
There is a way more effective way of doing it with \textbf{\hyperref[Comprehension]{comprehension}}.

\subsection{Filter function}
Filter function is a special function used to apply a selection for each element of a container. \textbf{map(function\_to\_apply, list)}
\begin{lstlisting}[language=Python]
liste = [1,2,3]
def filter_function(x):
	return x%2!=0
filtered_list = list(filter(filter_function,liste))

# before : [1, 2, 3] and now : [1, 3]
\end{lstlisting} \vspace{5mm}
There is a way more effective way of doing it with \textbf{\hyperref[Comprehension]{comprehension}}.

\subsection{Reduce function}


\newpage
\section{Class}
\label{sec:Class}
Classes are a way of bringing together data and functionality. Creating a new class creates a new type of object and so new instances of this type can be built.

\subsection{Instance}
An instance is an objet created from the parent class. \\
Each instance can have its own attributes, which defines its state. \\
An instance can also use methods from the class to modify its state.
\begin{lstlisting}[language=Python]
class MyClass(object):
	def __init__(self):
		pass

my_instance = MyClass()
\end{lstlisting} \vspace{5mm}

\subsection{Methods}
Methods are functions that bellow to the class. They are basically functions that uses attributes from the class. A method can be used by the instance as follow  : \textbf{my\_instance.my\_method()} except for class methods where \textbf{My\_class.my\_method()} is better.

\vspace{5mm}

Here is a simple example of some methods from the class Rectangle : 
\begin{lstlisting}[language=Python]
class Rectangle(object):
	def __init__(self,length,width):
		self.length = length
		self.width = width

	def perimeter(self):
		return (self.length + self.width)*2

	def area(self):
		return self.length * self.width
\end{lstlisting} \vspace{5mm}

\subsubsection{Static methods}
Static methods have a link with the class but don't use any attribute from it. There is no \textbf{self} in the parameters. It's often generic function that can apply a process on the attributes from the class.

\begin{lstlisting}[language=Python]
class Static(object):
	def __init__(self, position):
		self.position = position

	@staticmethod
	def DMS_to_DD(data): #coordinates
		for x in ['N', 'W','S','E']:
			try:
				if data[x] != '':
					data[x] = (data[x][1]*60+data[x][2])/3600.0 + data[x][0]
					if x == 'W' or x == 'S':
						data[x] = round(-data[x],5)
					else:
						data[x] = round(data[x],5)
				else:
					data[x] = ""
			except Exception as e:
				data[x] = ""
				print("Unable to convert " + data["name"] + " :" + e)
		return data
\end{lstlisting} \vspace{5mm}

\subsubsection{Class methods}
Class methods concerns the class itself and class variables. There is no \textbf{self} in the parameters but \textbf{cls}.

\begin{lstlisting}[language=Python]
class Class(object):
	nb_instance = 0
	def __init__(self):
		nb_instance+=1

	@classmethod
	def get_nb_instance(cls):
		return cls.nb_instance

print(Class.get_nb_instance()) #0
\end{lstlisting} \vspace{5mm}

Class methods can also be seen as class constructor. You can apply a process before creating the class and create it with the result of the process.

\vspace{5mm}

In this example, we apply the process of parsing the person before creating the class :

\begin{lstlisting}[language=Python]
class ClassConstructor(object):
	def __init__(self,first, last, age):
		self.first = first
		self.last = last
		self.age = age

	@classmethod
	def init_person(cls, person):
		first, last, age = person.split('-')
		return cls(first, last, age)

person = "Ewan-Carree-20"
p = ClassConstructor.init_person(person)
\end{lstlisting} \vspace{5mm}

\subsection{Dunder methods}
Dunder methods are specific function from a class, they are surrounded by \_\_. \\
It can be used by the instance as follow : \textbf{my\_instance.\_\_dunder\_method\_\_} \\
But it's better to use them like that : \textbf{dunder\_method(my\_instance)}
\begin{lstlisting}[language=Python]
class Point(object):
	def __init__(self, x=0,y=0):
		self.x = x
		self.y = y
		self.conteneur = [1,2,3,4,5,6,7]

	def __str__(self):
		print("I'm the class Point")

	def __add__(self, p):
		"""la fonction add surcharge l'operateur +"""
		return Point(self.x + p.x, self.y + p.y)

#	def __getattr__(self, name):
#		print(f"{name} didn't found")

	def __setattr__(self, name, value):
		"""On modifie la classe mere directement plutot que seulement appeler setaatr de cette classe et tourner en boucle sur la meme methode"""
		object.__setattr__(self, name, value) #Chaque classe cree herite de base de la classe object

	def __delattr__(self, name):
		print(f"Deleting {name} ...")

	def __getitem__(self, index):
		return self.conteneur[index]

	def __setitem__(self, index, value):
		self.conteneur[index] = value

	def __contains__(self, value): # 8 in ma_liste  <==>  ma_liste.__contains__(8)
		return True if value in self.conteneur else False

	def __len__(self):
		return len(self.conteneur)

	"""Autres surcharges : 

	__sub__(self,p) : -
	__mul__(self,p) : *
	__truediv__(self, p) : /
	__floordiv__(self, p) : //
	__mod__(self, p) : %
	__pow__(self, p) : **

	__gt__(self,p)  : >
	__ge__(self,p) 	: >=
	__lt__(self,p)  : <
	__le__(self,p)  : <=
	__eq__(self,p) : == 

	__iadd__(self,p) : +=
	__isub__(self,p) : -=
	__imul__(self,p) : *=
	__itruediv__(self, p) : /=	
	...
	"""
\end{lstlisting} \vspace{5mm}

\subsection{Class variables}
Class variables are useful in some cases. Imagine a variable that would always be used in the class and that the class always access. They are variables that the instance don't necessarily need.
\begin{lstlisting}[language=Python]
class ClassVariables(object):
	nb_instance = 0
	pourcentage = 1.1

	def __init__(self, price):
		self.price = price
		ClassVariables.nb_instance += 1

	def raise_price(self):
		self.price = round(self.price * self.pourcentage,2)

a = ClassVariables(100)
a.raise_price()
print(a.price) # 110.0
print(ClassVariables.nb_instance) # 1
\end{lstlisting} \vspace{5mm}
In this code, nb\_instance and pourcentage are my class variables, I access to them with ClassVariables.nb\_instance and self.pourcentage. I choose to write it like that so that I can possibly the pourcentage for each instance later but I won't be able to affect nb\_instance because it bellows to the class.

\subsection{Inheritance}
Inheritance is a concept of relation between classes. Some are parents, the other are children. A children inherit from every methods from the parent class but can overload them. A child class can have multiple parents.

\vspace{5mm}

Here is a useful example : a parent class that automatically initialize the childs :
\begin{lstlisting}[language=Python]
class Initializer:
    def __init__(self, *args, **kwargs):
        if kwargs and not args:
            print(f"kwargs is not empty : {kwargs}")
            for key, value in kwargs.items():
                setattr(self, key, value)
        else:
            raise ValueError("You didn't enter the correct arguments")
 
 
class MyClass(Initializer):
    def __str__(self):
        return f"I'm {self.__class__.__name__} and here are my attributes : {self.__dict__}"
 
 
my_instance = MyClass(a=1, b=2)
\end{lstlisting} \vspace{5mm}

Here is another example with multiple inheritance
\begin{lstlisting}[language=Python]
class Dog(object):
	def __init__(self, age):
		self.age = age
	def speak(self):
		print("Waf")
class Cat(Dog, Animal): #multiple inheritance : Cat have some attributs from Dog but is also an Animal
	def __init__(self, age, nom):
		super().__init__(age)
		self.nom = nom
	def speak(self):
		print("Miaou")
\end{lstlisting} \vspace{5mm}

\subsection{Property}
Property concerns the private and public aspect from a class even though everything is public in python. In python, a variable or method which start with \_ is considered as "private". Also, we need to create getters and setters to access and modify these privates elements. Property redirect calls of privates elements to these getters and setters.
\begin{lstlisting}[language=Python]
"""
Property : permet d'offrir des accesseurs et mutateurs pour definir un attribut prive

La methode donnant acces a l'attribut

La methode modifiant l'attribut

La methode appelee quand on souhaite supprimer l'attribut (optionnel)

La methode appelee quand on demande de l'aide sur l'attribut (optionnel)

"""
class Test(object):
	def __init__(self, x=0, y=0):
		self.x = x
		self.y = y
		self._dimension = 2 #Attribut prive

	def _get_dimension(self):
		return self._dimension

	def _set_dimension(self,value):
		self._dimension = value
		
	dimension = property(_get_dimension, _set_dimension) # lorsqu'on appelera objet.dimension, property redirigera vers les accesseurs/mutateurs prives
\end{lstlisting} \vspace{5mm}

There is another way of doing it in a more readable and better way with \hyperref[subsec:Property]{property decorator}.

\subsection{Metaclass}
Every class inherit from the \textit{object} class, metaclass is a way to define how to create our own classes without inheriting from \textit{object}.

\subsection{Other}
In python, everything is public so there isn't any private method or variable from a class. We can use \_ to tell to the user that we want it private even though it's not really.

\vspace{5mm}

In classes you can use self.\_\_my\_private\_attr = "I'm private".
It's called name scrambling and it is used to ensure that subclasses don't accidentally override the private methods and attributes of their superclasses. It's not designed to prevent deliberate access from outside. We can see it with : my\_instance.\_\_dict\_\_

\vspace{5mm}

There are some tips useful to know concerning class :
\begin{lstlisting}[language=Python]
print(dir(ma_instance)) #return a list of every dunder methods, methods and attributes from the class.
print(ma_instance.__dict__) # return a dict with attributes as keys and their value. associated.
print(issubclass(child_class, parent_class)) # return True if child_class is the child of parent_class.
print(isinstance(my_instance, my_class)) # return True if my_instance is an instance from my_class.
\end{lstlisting} \vspace{5mm}

\newpage
\section{Decorators}
A decorator is a design pattern in Python that allows a user to add new functionality to an existing object without modifying its structure. Decorators are usually called before the definition of a function you want to decorate. \textbf{@my\_decorator}

\subsection{Function decorator}

\subsubsection{With a function as decorator}
A decorator can be a function applied to wrap another function and apply a process on it each time it's called.
\begin{lstlisting}[language=Python]
import time
def timer(func):
	def wrapper(*args, **kwargs):
		start = time.time()
		rv = func(*args, **kwargs)
		total = time.time() - start
		print("Time to execute : "+ str(total))
		return rv
	return wrapper

@timer #we can chain decorators
def exemple(x):
	return "je suis "+str(x)
	
rv = exemple(5)
#Time to execute : 2.384185791015625e-06
print(rv) #je suis 5
\end{lstlisting} \vspace{5mm}

\subsubsection{With a class as decorator}
A decorator can also be a class applied to wrap a function and apply a process on it each time it's called.

\vspace{5mm}

Last code become :
\begin{lstlisting}[language=Python]
import time
class timer(object):
    def __init__(self, func):
        self.func = func
    def __call__(self, *args, **kwargs):
        start = time.time()
		rv = self.func(*args, **kwargs)
		total = time.time() - start
		print("Time to execute : "+ str(total))
		return rv

@timer #we can chain decorators
def exemple(x):
	return "je suis "+str(x)
	
exemple(5)
#Time to execute : 2.384185791015625e-06
print(rv) #je suis 5
\end{lstlisting} \vspace{5mm}

\subsection{Class decorator}
Classes can also be decorated the same way that we do with function.

\vspace{5mm}

Here is an useful example of a class that automatically initialize another class :
\begin{lstlisting}[language=Python]
class ClassInitializer:
    def __init__(self, cls):
        print("Entering __init__ ...")
        self.cls = cls
 
    def __call__(self, *args, **kwargs):
        print("Entering __call__ ...")
        obj = self.cls() # create an instance
 
        if kwargs and not args:
            print(f"kwargs is not empty : {kwargs}")
            for key, value in kwargs.items():
                setattr(obj, key, value) # set attributes to the new instance
        else:
            raise ValueError("You didn't enter the correct arguments")
        return obj
 
 
@ClassInitializer
class MyClass:
    def __str__(self):
        return f"I'm {self.__class__.__name__} and here are my attributes : {self.__dict__}"
 
 
my_instance = MyClass(a=1, b=2)
\end{lstlisting} \vspace{5mm}

\subsection{Multiple decorators}
You can chain decorators to apply multiple processes on the same function / class. 

\vspace{5mm}

Sometimes multiple decorators create conflicts between each other by manipulating the original function. You can fix this easily with the module \textbf{functools}. You need to add a \textbf{wraps(my\_func)} decorator on each wrapper function inside your decorators.

\vspace{5mm}

The function code become :
\begin{lstlisting}[language=Python]
import time
from functools import wraps
def timer(func):
    @wraps(func) #modification
	def wrapper(*args, **kwargs):
		start = time.time()
		rv = func(*args, **kwargs)
		total = time.time() - start
		print("Time to execute : "+ str(total))
		return rv
	return wrapper

#possibly another decorators here
@timer
def exemple(x):
	return "je suis "+str(x)
	
rv = exemple(5)
#Time to execute : 2.384185791015625e-06
print(rv) #je suis 5
\end{lstlisting} \vspace{5mm}

\subsection{Property decorator}
\label{subsec:Property}
Property decorator are one of the most useful decorator in classes to manage getters, setters and deleters. \textbf{@my\_method.getter/setter/deleter}\\
Indeed, when you use a variable that use some attributes and then you set later one of these attributes, it won't change in your variable which use attributes. \\
The way to manage it is by using property decorator into methods as attributes that replace the previous variable.

\vspace{5mm}

For example :
\begin{lstlisting}[language=Python]
class Myclass(object):
	def __init__(self, first, last):
		self.first = first
		self.last = last
		self.email = self.first + '.' + self.last + "@gmail.com"

	def fullname(self):
		return f"{self.first} {self.last}"
		
p1 = Myclass("Ewan", "Carree")
p1.first = "Lou-Anne"

print(p1.email) # Ewan.Carree@gmail.com -- first didn't change
print(p1.fullname()) # Lou-Anne Carree
\end{lstlisting} \vspace{5mm}
Will become :
\label{Del}
\begin{lstlisting}[language=Python]
class Myclass(object):
	def __init__(self, first, last):
		self.first = first
		self.last = last

	@property
	def email(self):
		 return self.first + '.' + self.last + "@gmail.com"

	@property
	def fullname(self):
		pass#return f"{self.first} {self.last}"

	@fullname.setter
	def fullname(self, name):
		first,last = name.split(' ')
		self.first = first
		self.last = last

	@fullname.getter
	def fullname(self):
		return f"{self.first} {self.last}"

	@fullname.deleter
	def fullname(self):
		print("deleting ...")
		# delete attributes, unable to use them later
		del self.first 
		del self.last

p1 = Myclass("Ewan", "Carree")
p1.fullname = "Lou-Anne Le_Bras"

print(p1.email) # Lou-Anne.Le_Bras@gmail.com
print(p1.fullname) # Lou-Anne Le_Bras
\end{lstlisting} \vspace{5mm}

\subsection{Decorator with argument(s)}
Sometimes you need to pass argument(s) into you decorator to modify the way your decorator is working. To solve that problem, you need to nest your previous decorator into a new function. 

\vspace{5mm}

Here is an example :

\begin{lstlisting}[language=Python]
import time
def add_prefix(prefix): #every function nested have access to that prefix : enclosing
    def timer(func):
    	def wrapper(*args, **kwargs):
    		start = time.time()
    		rv = func(*args, **kwargs)
    		total = time.time() - start
    		print(prefix + "Time to execute : "+ str(total))
    		return rv
    	return wrapper
    return timer

@add_prefix("exemple : ")
def exemple(x):
	return "je suis "+str(x)
	
rv = exemple(5)
# exemple : Time to execute : 2.384185791015625e-06
print(rv) #je suis 5
\end{lstlisting} \vspace{5mm}

\newpage
\section{Iterator / Iterable}
Every object that have the \textit{\_\_iter\_\_} dunder method is an \textbf{iterable} that can be looped over thanks to the iterator returned by this dunder method when \textbf{for loop} calls it. An \textbf{iterator} object is defined by the fact that it has the \textit{\_\_next\_\_} dunder method. 

\vspace{5mm}

Here is an iterable object that is also an iterator because it combines iter() and next() dunder methods :
\begin{lstlisting}[language=Python]
class MyRange:

    def __init__(self, start, end):
        self.value = start
        self.end = end

    def __iter__(self):
        return self

    def __next__(self):
        if self.value >= self.end:
            raise StopIteration
        current = self.value
        self.value += 1
        return current
\end{lstlisting} \vspace{5mm}

\subsection{Generators}
\label{subsec:Generators}
Generators are simple and powerful tools for creating iterators. They are written like regular functions but use the yield statement when they want to return data. Each time it is called by next(), the generator resumes execution where it left off (keeping all of its execution context). 

\vspace{5mm}

Also, we can create the equivalent of MyRange class with a function based on generator which is more readable than a class.
\begin{lstlisting}[language=Python]
def my_range(start, end):
    current = start
    while current < end:
        yield current
        current += 1

nums = my_range(1,3)

for num in nums:
    print(num)
# 1
# 2
# 3
\end{lstlisting} \vspace{5mm}

Here is an example of list against generator. If you run these function with lot of people, you'll see the strength of generators, instead of returning a list of lot of people, it will yield one person a the time. Also, it won't take any memory or any time instead of a list. \\
The only thing that change here is the \textbf{yield} keyword which is equivalent to the return keyword except the fact that it doesn't end the function but freeze it until the next call :
\begin{lstlisting}[language=Python]
def people_list(num_people):
    result = []
    for i in xrange(num_people):
        person = {
                    'id': i,
                    'name': random.choice(names),
                    'major': random.choice(majors)
                }
        result.append(person)
    return result
    
def people_generator(num_people):
    for i in xrange(num_people):
        person = {
                    'id': i,
                    'name': random.choice(names),
                    'major': random.choice(majors)
                }
        yield person
\end{lstlisting} \vspace{5mm}


\subsection{For}
\label{subsec:For}
For loop are the most powerful way to work on data contained in list, tuple, dict, string, files, generators, ... 

\subsubsection{Range}
Range allows user to loop a certain times. \textbf{range(start,end, step)}
\begin{lstlisting}[language=Python]
for x in range(2):
	print(x)
#0
#1
\end{lstlisting} \vspace{5mm}

\subsubsection{Enumerate}
Enumerate is a very good way to work with for loop. You can access simultaneously to the element and it's position in a tuple.
\begin{lstlisting}[language=Python]
liste = ['a', 'b', 'c']
for index, elem in enumerate(liste):
	print(f"{elem} at position {index}")
# a at position 0
# b at position 1
# c at position 2
\end{lstlisting} \vspace{5mm}

\subsubsection{Zip}
Zip is another loop method. You can combine multiple lists with the same length in the loop. 
\begin{lstlisting}[language=Python]
names = ["Peter Parker", "Clark Kent", "Wade Wilson", "Bruce Wayne"]
heroes = ["Spiderman", "Superman", "Deadpool", "Batman"]
universes = ["Marvel", "DC", "Marvel", "DC"]

for name, hero, universe in zip(names, heroes, universes):
	print(f"{name} is actually {hero} from {universe}")
	
# Peter Parker is actually Spiderman from Marvel
# Clark Kent is actually Superman from DC
# Wade Wilson is actually Deadpool from Marvel
# Bruce Wayne is actually Batman from DC
\end{lstlisting} \vspace{5mm}


\newpage
\section{Modules}
Modules are Python programs that contain functions that we often reuse (we also call them libraries or libraries). These are “toolboxes” that will be very useful to you.

\subsection{Import}
\label{subsec:Import}

\subsubsection{Import module as}
\label{As}
Sometimes you import modules but it's very long to write methods from a long module name. Plus, it's not good to use the \textit{import * from module} because it can creates conflicts between function and class that have the same name in two different modules. Rather than writing module.class you can use the key word \textbf{as}. It very used for libraries like numpy as np, matplotlib.pyplot as plt and scipy.signal as sig


\subsection{Time}
\subsubsection{Time}
For further explanations, see the \href{https://docs.python.org/3/library/time.html}{official documentation}

\subsubsection{Datetime}
For further explanations, see the \href{https://docs.python.org/3/library/datetime.html}{official documentation}

\subsection{Password}
\subsubsection{Getpass}
Get pass is a very useful module to enter password secretly. In deed, it doesn't show the characters entered.
\begin{lstlisting}[language=Python]
mdp getpass.getpass("Type your password : ")
\end{lstlisting} \vspace{5mm}

For further explanations, see the \href{https://docs.python.org/3/library/getpass.html}{official documentation}

\subsubsection{Hashlib}
You can secure you password get from getpass by hashing them into different hash algorithm.\\
To see every hash algorithms you can type this command : 
\begin{lstlisting}[language=Python]
hashlib.algorithms_guaranteed
\end{lstlisting} \vspace{5mm}
First, you are going to encode your password into bytes. Then, use the hash algorithm.
\begin{lstlisting}[language=Python]
mot_de_passe = hashlib.sha1(b"mot de passe")
\end{lstlisting} \vspace{5mm}
Finally, you'll need to transform your hashed password into bytes or string. String is more readable and reusable.
\begin{lstlisting}[language=Python]
mot_de_passe.hexdigest()
\end{lstlisting} \vspace{5mm}
Then you can save this password and compare it to the password entered by the user to see if it corresponds.

\vspace{5mm}

For further explanations, see the \href{https://docs.python.org/3/library/hashlib.html}{official documentation}


\subsection{Os}
\subsubsection{Working repertory}
You can get you actual working repertory by using :
\begin{lstlisting}[language=Python]
my_repertory = os.getcwd()
\end{lstlisting} \vspace{5mm}

\subsubsection{Terminal commandline}
You can run terminal commandlines by using : (look out for commands that corresponds with the os terminal you are running you program in)
\begin{lstlisting}[language=Python]
os.system("ls")

#get the value returned with
cmd = os.popen("ls")
cmd.read()
\end{lstlisting} \vspace{5mm}

\subsection{Sys}
\subsubsection{Import module from another repertory}
Sometimes you need to import a module that isn't into you actual repertory, rather than copy this module into you repertory you can import it by another way. 

\vspace{5mm}

Tree exemple : 

Main/ 

....main.py 

....Test/ 

........test.py 

\begin{lstlisting}[language=Python]
import sys
sys.path.append("./Test")
import test # .py file (module)
\end{lstlisting} \vspace{5mm}

Another way to do this in a more effective way is to set \textbf{\hyperref[subsec:PathVariables]{path variables}}.

\subsubsection{Memory used by a variable}
Control you memory while programming. 
\begin{lstlisting}[language=Python]
var = [1]*100
print(f"memoire utilisee par var : {sys.getsizeof(var)} bytes") #memoire utilisee par var : 856 bytes
\end{lstlisting} \vspace{5mm}

\subsubsection{Redirect flow}
We can redirect the flow to write directly somewhere instead of the terminal.
\begin{lstlisting}[language=Python]
file = open("output.txt", 'w')
sys.stdout = fichier # return to original flow with sys.__stdout__
\end{lstlisting} \vspace{5mm}

\subsubsection{Exit program}
You can exit the program any time you want when it's running. The parameter inside the function is important to specify to the user is there has been a problem or not; 0 means no problem and anything else (often 1) means that there has been a problem.
\begin{lstlisting}[language=Python]
sys.exit(parameter)
\end{lstlisting} \vspace{5mm}

\subsubsection{Get parameters passed in the call}
You can get any parameter specified by the user when he runned the program. (if an parameter is separated by space(s), sourround him by "").
\begin{lstlisting}[language=Python]
sys.argv
\end{lstlisting} \vspace{5mm}

\subsection{Math}
For further explanations, see the \href{https://docs.python.org/3/library/math.html}{official documentation}

\subsection{Random}
For further explanations, see the \href{https://docs.python.org/3/library/random.html}{official documentation}

\subsection{Argparse}
You can parse argument(s) passed in the call of program using argparse.
\begin{lstlisting}[language=Python]
parser = argparse.ArgumentParser()

#add instruction when user type program.py --help/-h
#imagine we need an compulsory argument of type int :
parser.add_argument("x", type=int, help="description of x")
#imagine that the user can specify an other optional argument:
parser.add_argument("-v", "--verbose", action="store_true", help="add more explanation")

#save arguments
args = parser.parse_args()

#get args
print(args.x)
if args.verbose:
    print("I add more explanations")
\end{lstlisting} \vspace{5mm}
For further explanations, see \href{http://www.sharelatex.com}{argparse tutorial} or  \href{https://docs.python.org/3/library/argparse.html}{official documentation}.


\subsection{Unittest}
In every program it's very useful to test every functionnality that we propose. Unittest is a powerful module to test our code. You have to create another module starting with "test" into the same repertory from your main program.

\vspace{5mm}

Here is an exemple of hos to use this module :
\begin{lstlisting}[language=Python]
import random
import unittest

class RandomTest(unittest.TestCase):

    """Test case utilise pour tester les fonctions du module 'random'."""

    def setUp(self):
        """Initialisation des tests."""
        self.liste = list(range(10))

    def test_choice(self):
        """Test le fonctionnement de la fonction 'random.choice'."""
        elt = random.choice(self.liste)
        self.assertIn(elt, self.liste)

    def test_shuffle(self):
        """Test le fonctionnement de la fonction 'random.shuffle'."""
        random.shuffle(self.liste)
        self.liste.sort()
        self.assertEqual(self.liste, list(range(10)))

    def test_sample(self):
        """Test le fonctionnement de la fonction 'random.sample'."""
        extrait = random.sample(self.liste, 5)
        for element in extrait:
            self.assertIn(element, self.liste)

        with self.assertRaises(ValueError):
            random.sample(self.liste, 20)
\end{lstlisting} \vspace{5mm}
def setUp(self) is similar to def \_\_init\_\_(self), that's where you define generalities.
Then create a function for each functionnality, it must correspond with the right assertion method.

\vspace{5mm}

Here are every assertion methods you can use to test your functionnalities.
\begin{table}[h]
\begin{center}
{\renewcommand{\arraystretch}{1} %donne la distance entre les lignes%
{\setlength{\tabcolsep}{0.5cm} %donne la distance entre les collones%
\begin{tabular}{|c|c|}
  \hline
  assertEqual(a, b) & a == b \\
  \hline
  assertNotEqual(a, b) & a != b \\
  \hline
  assertTrue(x) & x is True \\
  \hline
  assertFalse(x) & x is False \\
  \hline
  assertIs(a, b) & a is b \\
  \hline
  assertIsNot(a, b) & a is not b \\
  \hline
  assertIsNone(x) & x is None \\
  \hline
  assertIsNotNone(x) & x is not None \\
  \hline
  assertIn(a, b) & a in b \\
  \hline
  assertNotIn(a, b) & a not in b \\
  \hline
  assertIsInstance(a, b) & isinstance(a, b) \\
  \hline
  assertNotIsInstance(a, b) & not isinstance(a, b) \\
  \hline
  assertRaises(exception, fonction, *args, **kwargs) & \makecell{check if function \\ raise the good exception}  \\
  \hline
\end{tabular}}}
\end{center}
\caption{Assertion methods}
\end{table}

After creating this module, you can test it by two different ways. The first one is \textbf{unittest.main()} but the other one is much more convenient. Go into the repertory into a terminal where you project and test file are stored and type the command \textbf{pythonX -m unittest}. It will run automatically each test.

\vspace{5mm}

For further explanations, see the \href{https://docs.python.org/3/library/unittest.html}{official documentation}


\subsection{Re}
Regex also known as regular expression is a very powerful module for searching in string. \textbf{re.search(expression, string)} with \textbf{expression = r"..."}

\begin{table}[h]
\begin{center}
{\renewcommand{\arraystretch}{2} %donne la distance entre les lignes%
{\setlength{\tabcolsep}{1.5cm} %donne la distance entre les collones%
\begin{tabular}{|l|c|r|}
  \hline
  \makecell{$\land$ \\ start} & \makecell{* \\ 0,1,...} & \makecell{\{\} \\ n times} \\
  \hline
  \makecell{\$ \\ end} & \makecell{+ \\ 1,...} & \makecell{[] \\ sth inside} \\
  \hline
  \makecell{? \\ 0 or 1} & \makecell{() \\ group} &  \\
  \hline
\end{tabular}}}
\end{center}
\caption{Regex methods}
\end{table}

\vspace{5mm}

Example :
\begin{lstlisting}[language=Python]
# I want to find a phone number with digits separated by a space, a point or an hyphen.
expression = r"^0[0-9]([ .-]?[0-9]{2}){4}$"
# I want a password with at least 6 characters and containing number or letter or both.
expression = r"^[A-Za-z0-9]"
\end{lstlisting} \vspace{5mm}

See more explanation about re on the \href{https://docs.python.org/3/library/re.html?highlight=re#module-re}{official documentation}

\subsection{cx\_Freeze / setup}
You can create .exe program that anybody can run on its own computer without having python or the extern libraries installed by using the module cx\_Freeze.

\vspace{5mm}

To create a .exe file on windows : open a new terminal and go into the repertory
\begin{lstlisting}[language=Python]
C:\Users\carre\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.8_qbz5n2kfra8p0\LocalCache\local-packages\Python38\Scripts
\end{lstlisting} \vspace{5mm}

\vspace{5mm}

Then, run \textit{./cxfreeze pathTo.pyFile} and a \textit{dist} folder will be created with every libraries needed and the .exe file that you can directly run. You can send a zip file of this dist folder to every one so that they can run your program on their own computer.

\vspace{5mm}

You can do the same on linux by simply do \textit{cxfreeze myfile.py} and you'll get exactly the same except the fact that it is an ubuntu file.

\vspace{10mm}

You can do the same by creating a setup.py file.

\vspace{5mm}

Your setup file will look like this : 
\begin{lstlisting}[language=Python]
from cx_Freeze import setup, Executable

setup(
    name = "myFile",
    version = "0.1",
    description = "desciption",
    executables = [Executable("myFile.py")],
)
\end{lstlisting} \vspace{5mm}

Then run \textit{python.exe setup.py build} in your windows terminal and \textit{python3 setup.py build} into your ubuntu terminal. It will create a \textit{build} folder with every necessary files inside. It's more powerfull than cx\_Freeze.

See more explanation about cx\_Freeze on the  \href{https://cx-freeze.readthedocs.io/en/latest/}{official documentation}

\subsection{Network}
With network you can exchange data between a client and a server following the TCP protocol. To establish a connection between client and server, you need an host name and a port number. 
\vspace{5mm}


Here is an example of client and server :

\vspace{5mm}

Server side
\begin{lstlisting}[language=Python]
import socket
import select

hote = ''
port = 12800

connexion_principale = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
connexion_principale.bind((hote, port))
connexion_principale.listen(5)
print("Le serveur ecoute a present sur le port {}".format(port))

serveur_lance = True
clients_connectes = []
while serveur_lance:
    # On va verifier que de nouveaux clients ne demandent pas a se connecter
    # Pour cela, on ecoute la connexion_principale en lecture
    # On attend maximum 50ms
    connexions_demandees, wlist, xlist = select.select([connexion_principale],
        [], [], 0.05)
    
    for connexion in connexions_demandees:
        connexion_avec_client, infos_connexion = connexion.accept()
        # On ajoute le socket connecte a la liste des clients
        clients_connectes.append(connexion_avec_client)
    
    # Maintenant, on ecoute la liste des clients connectes
    # Les clients renvoyes par select sont ceux devant etre lus (recv)
    # On attend la encore 50ms maximum
    # On enferme l'appel a select.select dans un bloc try
    # En effet, si la liste de clients connectes est vide, une exception
    # Peut etre levee
    clients_a_lire = []
    try:
        clients_a_lire, wlist, xlist = select.select(clients_connectes,
                [], [], 0.05)
    except select.error:
        pass
    else:
        # On parcourt la liste des clients a lire
        for client in clients_a_lire:
            # Client est de type socket
            msg_recu = client.recv(1024)
            # Peut planter si le message contient des caracteres speciaux
            msg_recu = msg_recu.decode()
            print("Recu {}".format(msg_recu))
            client.send(b"5 / 5")
            if msg_recu == "fin":
                serveur_lance = False

print("Fermeture des connexions")
for client in clients_connectes:
    client.close()

connexion_principale.close()
\end{lstlisting} \vspace{5mm}
Client side :
\begin{lstlisting}[language=Python]
import socket

hote = "localhost" #car nous avons les deux serveurs sur la meme machine
port = 12800 #port du serveur qui ecoute

connexion_avec_serveur = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
connexion_avec_serveur.connect((hote, port))
print("Connexion etablie avec le serveur sur le port {}".format(port))

msg_a_envoyer = b""
while msg_a_envoyer != b"fin":
    msg_a_envoyer = input("> ")
    # Peut planter si vous tapez des caracteres speciaux
    msg_a_envoyer = msg_a_envoyer.encode()
    # On envoie le message
    connexion_avec_serveur.send(msg_a_envoyer)
    msg_recu = connexion_avec_serveur.recv(1024)
    print(msg_recu.decode()) # La encore, peut planter s'il y a des accents

print("Fermeture de la connexion")
connexion_avec_serveur.close()
\end{lstlisting} \vspace{5mm}

\subsubsection{Socket}
Sockets allow us to open a connexion between two or more computer. Ports available are included between 1024 and 65535. 

\vspace{5mm}

For further explanations, see the \href{https://docs.python.org/3/library/socket.html}{official documentation} and socketserver  \href{https://docs.python.org/3/library/socketserver.html}{official documentation} 
\subsubsection{Select}
For further explanations, see the \href{https://docs.python.org/3/library/select.html}{official documentation}

\subsection{Threads}
\label{subsec:Threading}
Threading is an advanced module especially used to run multiple processes at the same time. Normally, each functin call follow each other in one way. But with threading you can run them simultaneously. It's especially useful when a call lasts a lot of time, with threading, you don't waste this time.

\vspace{5mm}

For further explanations, see the \href{https://docs.python.org/3/library/threading.html}{official documentation}


\subsection{Inspect}
If you're interested in knowing how a class is built you can use the inspect module. It prints out the full code from the class. You can't use this function on built-in module like math, os, ... because it's not written in python.
\begin{lstlisting}[language=Python]
import inspect
from queue import Queue
print(f"Code source : \n{inspect.getsource(Queue)}")
\end{lstlisting} \vspace{5mm}

\subsection{Operator}
\label{subsec:Operator}

\newpage
\section{Toolbox}
\subsection{Break / Continue / Pass / Return}
\label{subsec:BCPR}
\begin{lstlisting}[language=Python]
#pass is similar to an empty instruction.
if True:
    pass

#return is used in function to give a response to a call.
def func():
	"""this is a docstring, use help(func) to know more about this function."""
	return "j'ai retourne une phrase"

#break and continue are used in loop to modify the way the loop is looping.
nb = 3
while nb != 20:
	if nb>6:
		break #End the loop
	nb+=1
	if nb==5:
		continue #Go to the top of the loop without executing the rest.	
	print(nb)

#4
#6
#7
\end{lstlisting} \vspace{5mm}

\subsection{Is vs ==}
\label{subsec:Is}
We can think that \textbf{is} and \textbf{==} are exactly the same but it's not the case. \textbf{==} is based on the fact that two objects' elements are exactly the same. Instead, \textbf{is} compare if the two objects belong to the same memory adress.\\
\textbf{is} cans be seen as \textbf{id(obj1) == id(obj2)} if we want to compare it to \textbf{==}.

\vspace{5mm}

Here is an example :
\begin{lstlisting}[language=Python]
list1 = [1,2,3,4]
list2 = [1,2,3,4]

list1 == list2 #True
list1 is list2 #False

list1 = [1,2,3,4]
list2 = list1

list1 == list2 #True
list1 is list2 #True
\end{lstlisting} \vspace{5mm}

\subsection{Global/Nonlocal variables}
\label{subsec:Global/Nonlocal}
Variables that are created outside of a function (as in all of the examples above) are known as global variables.\\
Global variables can be used by everyone, both inside of functions and outside.
\begin{lstlisting}[language=Python]
a = b = 5
#a = 5 et b = 5
def modify(b):
	global a #modify the variable outside the function
	a*=2
	b*=2

modify(b)
#a = 10 et b = 5
\end{lstlisting} \vspace{5mm}

Variables that are nested into multiple functions are known as nonlocal variables. \\
Nonlocal variables can be used outside the nested function but inside the parent function.
\begin{lstlisting}[language=Python]
def method():

    def method2():
        # In nested method, reference nonlocal variable.
        nonlocal value
        value = 100

    # Set local.
    value = 10
    method2()

    # Local variable reflects nonlocal change.
    print(value)

method() #100
\end{lstlisting} \vspace{5mm}

\subsection{Keywords}
\label{subsec:Keyword}
You can use small keywords to simplify you code in many ways like checking if a set of variable is equal to the value we want.
\begin{lstlisting}[language=Python]
x,y,z = 0,1,0
if 1 in (x,y,z):
    pass
if x or y or z:
    pass
if any((x,y,z)):
    pass
if x and y and z:
    pass
    
value = None
if value is None:
    pass

if value is not None:
    pass
\end{lstlisting} \vspace{5mm}

\subsection{If / Elif / Else}
\label{IEE}
You can write if / else conditions in an easy way in python :
\begin{lstlisting}[language=Python]
condition = False

#Bad way :
if condition:
	x=1
else:
	x=0
	#0

#Good way :
x = 1 if condition else 0
#0
\end{lstlisting} \vspace{5mm}

\subsection{Exception}
In python you can handle exceptions that may occur when your program is running. \textit{We can always use \textbf{except Exception as e} but it's better to be the most precise possible.}
\subsubsection{Try / Except / Else / Finally}
This is the basic structure to handle exception :
\label{TEEF}
\begin{lstlisting}[language=Python]
nom = "Jerome"
try:
	key = int(nom)
except ValueError:
	print("Votre nom ne peut pas etre convertit en integer")
else: #done if try is ok
	print("Key as been validated")
finally: #always done
	print("end ...")
	
#Votre nom ne peut pas etre convertit en integer
#end ...
\end{lstlisting} \vspace{5mm}

We can also create our own exception by creating a new class.
\begin{lstlisting}[language=Python]
#Creer notre propre exception : La methode __str__ de la classe est ce qui est appele pour afficher le message d'erreur
class MonException(Exception):
    """Exception levee dans un certain contexte qui reste a definir"""
    def __init__(self, message):
        """On se contente de stocker le message d'erreur"""
        self.message = message
    def __str__(self):
        """On renvoie le message"""
        return self.message
\end{lstlisting} \vspace{5mm}

\subsubsection{Raise}
\label{Raise}
If you want to personalize the way a process handle exceptions you can use the \textbf{raise} keyword. \\
Imagine that we don't want a person to be minor :
\begin{lstlisting}[language=Python]
class Person(object):
    def __init__(self,nom,age):
        self.nom = nom
        if age >= 18:
            self.age = age
        else:
            raise Exception("Too young!")
\end{lstlisting} \vspace{5mm}

\subsection{Context manager}
\label{subsec:ContextManager}
Context Managers are great for when we need to setup or teardown some resources during use. So these can be used for: open and closing files, opening and closing database connections, acquiring and releasing locks, and much much more.

\begin{lstlisting}[language=Python]
import os
from contextlib import contextmanager


@contextmanager
def change_dir(destination):
    try:
        cwd = os.getcwd()
        os.chdir(destination)
        yield
    finally:
        os.chdir(cwd)


with change_dir('Sample-Dir-One'):
    print(os.listdir())

with change_dir('Sample-Dir-Two'):
    print(os.listdir())
\end{lstlisting} \vspace{5mm}

You can see some other examples of context manager in these sections : \hyperref[subsec:Files]{files} and \hyperref[subsec:Threading]{threading}

\subsection{Files}
\label{subsec:Files}

\subsection{F-string}
\label{subsec:F-string}
There is a simple way to write argument in you print() function. It's called F-string. A lot of methods come with it. \textbf{print(f"blabla \{my\_argument\} blabla")}
\begin{lstlisting}[language=Python]
for n in range(2):
	print(f"n = {n:03}")
#n = 000
#n = 001

pi = 3.141592
print(f"pi = {pi:.2f}") 
# pi = 3.14
\end{lstlisting} \vspace{5mm}

You can see more methods by looking specifically on every module you want, for example datetime f-string.

\subsection{Else clause on loop}
\label{subsec:Else}
Else can be used in many case like in the structure if/elif/else oftenly. But we can also use it in loops like for or while. It is similar to the finally statement of try/except. \\
It is always runned except if the loop encounter the \textbf{break} keyword.

\begin{lstlisting}[language=Python]
for i in range(2):
    print(i)
else: #doesn't encounter break
    print("Loop finished")
#0
#1
#Loop finished

i=0
while i<5:
    print(i)
    i+=1
    if i == 3:
        break
else: #encounter break before end
    print("Loop finished")
#0
#1
#2
\end{lstlisting} \vspace{5mm}

\subsection{Assertion}
\label{subsec:Assertion}
You can verify a condition before parsing an information by checking the instance type.
\begin{lstlisting}[language=Python]
b = 3
assert isinstance(b, int)
\end{lstlisting} \vspace{5mm}

\subsection{// and **}
There are two basics operations in python very useful instead of using a math method.
\begin{lstlisting}[language=Python]
print(f"10 / 3 = {10 / 3}") # 10 / 3 = 3.3333333333333335
print(f"10 // 3 = {10 // 3}") # 10 // 3 = 3

print(f"3**3 = {3**3}"}) # 3**3 = 9
\end{lstlisting} \vspace{5mm}

\subsection{Cast}
Sometimes you need to convert a variable from a certain type to another. Cast is a good way to do it but you've to know that you can lose information by doing it. 

You can do it by simply follow this pattern : \textbf{new\_type(my\_variable)}
Notice that you have to be coherent in your type transformation. For example, you won't be able to cast a string into an integer if your string = "Salut".

\subsection{Hash-Bang}
You can precise path to your python compilator in the second line of your .py document.
\begin{lstlisting}[language=Python]
# !/usr/bin/python3
\end{lstlisting} \vspace{5mm}

\subsection{Environment path Variables}
\label{subsec:PathVariables}

\subsection{Infinite loop}
\label{subsec:While}
You can create infinite loop in many case to run tasks in continue while your program is running. \\
You can create it this way :
\begin{lstlisting}[language=Python]
while True:
    #mytask
\end{lstlisting} \vspace{5mm}

\end{document}
