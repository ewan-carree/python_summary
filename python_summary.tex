\documentclass[a4paper, 12pt]{article} %document type
\usepackage[utf8]{inputenc} %encoding
\usepackage[T1]{fontenc}    
\usepackage[english]{babel} %language

\title{\textbf{python\_summary}}
\author{Ewan Carrée}
\date{August 2020}

%manage cells in tables
\usepackage{makecell}

%manage colors
\usepackage{xcolor}
%\usepackage{color}

%New colors defined below
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% add code
\usepackage{listings}
%Code listing style named "mystyle"
\lstdefinestyle{mystyle}{
  backgroundcolor=\color{backcolour},   commentstyle=\color{codegray},
  keywordstyle=\color{magenta},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{black},
  basicstyle=\ttfamily\footnotesize,
  breakatwhitespace=false,         
  breaklines=true,                 
  captionpos=b,                    
  keepspaces=true,                 
  numbers=left,                    
  numbersep=5pt,                  
  showspaces=false,                
  showstringspaces=false,
  showtabs=false,                  
  tabsize=4
}
%"mystyle" code listing set
\lstset{style=mystyle}

%\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry} 

%extern and intern links
\usepackage{hyperref} %links
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    urlcolor=blue,
    linktoc=all
}

\iffalse % start ignore code
%Python code highlighting
\begin{lstlisting}[language=Python]

\end{lstlisting}
\fi % end ignore code







\begin{document}

\maketitle
\newpage

\tableofcontents

\newpage
\section{Python reserved words}
In python 3, there are some reserved words that you can't use in your program as variables, function name, class name, ... \\ \\ \\

\begin{table}[h]
\begin{center}
{\renewcommand{\arraystretch}{2} %donne la distance entre les lignes%
{\setlength{\tabcolsep}{1.5cm} %donne la distance entre les collones%
\begin{tabular}{|l|c|r|}
  \hline
  \hyperref[subsec:Bool]{False} & None & \hyperref[subsec:Bool]{True} \\
  \hline
  and & \hyperref[As]{as} & \hyperref[subsec:Assertion]{assert} \\
  \hline
  \hyperref[subsec:BCPR]{break} & \hyperref[sec:Class]{class} & \hyperref[subsec:BCPR]{continue} \\
  \hline
  \hyperref[sec:Function]{def} & del & \hyperref[IEE]{elif} \\
  \hline
  \hyperref[IEE]{else} & \hyperref[TEEF]{except} & \hyperref[TEEF]{finally} \\
  \hline
  \hyperref[subsec:For]{for} & from & \hyperref[subsec:Global]{global} \\
  \hline
  \hyperref[IEE]{if} & \hyperref[subsec:Import]{import} & \hyperref[subsec:ListComprehension]{in} \\
  \hline
  is & \hyperref[subsec:Lambda]{lambda} & nonlocal \\
  \hline 
  not & or & \hyperref[subsec:BCPR]{pass} \\
  \hline 
  \hyperref[Raise]{raise} & \hyperref[subsec:BCPR]{return} & \hyperref[TEEF]{try} \\
  \hline
  while & \hyperref[subsec:ContextManager]{with} & \hyperref[sec:Generators]{yield} \\
  \hline
\end{tabular}}}
\end{center}
\caption{Reserved words}
\end{table}



\clearpage
\section{Types}
Python offers different basics types that are often enough for your program.\newline

\subsection{Immutable}
Immutable means that you can't directly modify your variable after you've assigned it. You have to reassign or create a new variable to work on a previous one\newline

\subsubsection{String}
Python string is an ordered collection of characters which is used to represent and store the text-based information. Strings are stored as individual characters in a contiguous memory location. It can be accessed from both directions: forward and backward. A string can be seen in some ways as a list of characters. \\It's better to use ' for as single character and " for a chain. \\ \\
Here are some methods that you can apply on strings (I choose to reassign the variable whenever it's possible) : 
\begin{itemize}
\begin{lstlisting}[language=Python]
string = "Hello, world!"
\end{lstlisting}

\item Upper case \\
Return a string with every single element from the original one in uppercase.
\begin{lstlisting}[language=Python]
string = string.upper()
# HELLO, WORLD!
\end{lstlisting}

\item Lowercase \\
Return a string with every single element from the original one in lowercase.
\begin{lstlisting}[language=Python]
string = string.lower()
# hello, world!
\end{lstlisting}

\item Captital \\
Return a string with the first Letter in uppercase and the rest in lowercase.
\begin{lstlisting}[language=Python]
string = string.capitalize()
# Hello, world!
\end{lstlisting}

\item Strip \\
Return a string whithout the blank spaces from both sides of the original string.
\begin{lstlisting}[language=Python]
string = string.strip()
\end{lstlisting}

\item Find \\
Return an integer which is the position of the first argument found in the string from left to right.
\begin{lstlisting}[language=Python]
position = string.find('l')
# 2
\end{lstlisting}

\item Count \\
Return an integer that represents the number of occurences of the argument found in the string. 
\begin{lstlisting}[language=Python]
nb = string.count('l')
# 3
\end{lstlisting}

\item Replace \\
Return a string where at least a part of it have been replaced by some another words.
\begin{lstlisting}[language=Python]
string = string.replace("world", "dlrow")
# Hello, dlrow!
\end{lstlisting}

\item Multiply \\
Return a string with n times the original string.
\begin{lstlisting}[language=Python]
string = string*3
# Hello, dlrow!Hello, dlrow!Hello, dlrow!
\end{lstlisting}

\item String to List \\
Transform your string into a list.
\begin{lstlisting}[language=Python]
tableau = string.split(' ')
# ['Hello,', 'dlrow!Hello,', 'dlrow!Hello,', 'dlrow!']
\end{lstlisting}

\item Fill \\
Return a string filled with zero to correspond to have the same digit in every number.
\begin{lstlisting}[language=Python]
string = '5'
string = string.zfill(3)
# 005
\end{lstlisting}
\end{itemize}

\subsubsection{Integer}
You can write very long number in a more readable way with \_ : 
\begin{lstlisting}[language=Python]
nb = 1_000_000
# 1000000
\end{lstlisting}

\subsubsection{Float}
You can handle decimal to choose how many decimal you need. You can modify it by two different ways : 
\begin{lstlisting}[language=Python]
my_float = 3.3333333
print("%.0f" % my_float + "with no decimal and " + "%.2f" % my_float + "with two decimals") #3 with no decimal and 3.33 with two decimals
round(my_float, 3) # 3.333
\end{lstlisting}

\subsubsection{Tuple}
A tuple is a container that can contain multiple variables with multiple types that have a link together. \\
\begin{itemize}
\item Unpack \\
You can unpack each variable from a tuple very easily in python as follow \textbf{first\_variable, ..., n\_variable = my\_tuple\_with\_n\_variable}
\begin{lstlisting}[language=Python]
my_tuple = (1,2)

#unpack :
a, b = my_tuple #1 and 2
\end{lstlisting}

\item Ignore unpacked variables \\
When you unpack tuple arguments, sometimes some argument aren't useful, the common way to write it is with \_
\begin{lstlisting}[language=Python]
my_tuple = (1,2)
my_tuple2 = (1,2,3,4,5)

#We don't need b :
a, _ = my_tuple #1

#Another example :
for _ in range(2):
	print("I don't care about i")
#I don't care about i
#I don't care about i

#Another example :
a, b, *_ = my_tuple2 #We ignore everything after the first two variables, the rest is stored in a list.
a, b, *c, d = my_tuple2 
print(f"{a}, {b}, {c}, {d}") #1, 2, [3, 4], 5
\end{lstlisting}
\end{itemize}


\subsubsection{Bool}
\label{subsec:Bool}
There is only two types of Boolean : True and False. \\
Everything can be considered as True if it different from 0 or False. \\
\begin{lstlisting}[language=Python]
a = "Salut"
b = 0
if a:
	print("a fonctionne")
	# a fonctionne
else:
	print("a ne fonctionne pas")

if b:
	print("b fonctionne")
else:
	print("b ne fonctionne pas")
	# b ne fonctionne pas
\end{lstlisting}

\subsection{Mutable}
Mutable means that if you are working on a variable, you directly modify it and don't need to create a new variable or reassign the previous one. It can cause conflict if two process are using the same variable that can be changed.\newline

\subsubsection{List}
A list is a container that can contain multiple variables with multiple types that have a link together.\\ \\
Here are some methods that you can apply on lists : 

\begin{lstlisting}[language=Python]
tableau = ['Hello,', 'dlrow!Hello,', 'dlrow!Hello,', 'dlrow!']
\end{lstlisting}

\begin{itemize}
\item Add \\
You can merge two lists into single one containing elements from both original lists.
\begin{lstlisting}[language=Python]
new_tab = first_part + second_part
# ['Hello,', 'dlrow!Hello,', 'dlrow!Hello,', 'dlrow!']
\end{lstlisting}

\item Multiply \\
Just like a string, you can multiply your list.
\begin{lstlisting}[language=Python]
multilpied_new_tab = new_tab *3
# ['Hello,', 'dlrow!Hello,', 'dlrow!Hello,', 'dlrow!', 'Hello,', 'dlrow!Hello,', 'dlrow!Hello,', 'dlrow!', 'Hello,', 'dlrow!Hello,', 'dlrow!Hello,', 'dlrow!']
\end{lstlisting}

\item Index \\
Return an integer which correspond to the position of the element searched.
\begin{lstlisting}[language=Python]
position = tableau.index('A')
# 1
\end{lstlisting}

\item Range \\
You can initialize a list of n ascending numbers easily with : 
\begin{lstlisting}[language=Python]
my_list = list(range(n))
\end{lstlisting}

\item List to String \\
Transfrom your list into a string.
\begin{lstlisting}[language=Python]
string = ' '.join(tableau)
# Hello, A dlrow!Hello, dlrow!Hello, dlrow!
\end{lstlisting}
\end{itemize}

\subsubsection{Dict}
A dict is an non-organized container that have variables associated to keys to recognize them. Keys are offently strings but we can also use integers.\\ \\
Here are some methods that you can apply on dicts : 
\begin{lstlisting}[language=Python]
dictionnaire = {"nom":"Jerome", "age":20}
\end{lstlisting}

\begin{itemize}
\item Keys \\
Return a (dict)list containing every keys that are into you dictionnary.
\begin{lstlisting}[language=Python]
keys = dictionnaire.keys()
#dict_keys(['nom', 'age'])
\end{lstlisting}

\item Values \\
Return a (dict)list containing every values that are into you dictionnary.
\begin{lstlisting}[language=Python]
keys = dictionnaire.keys()
#dict_values(['Jerome', 20])
\end{lstlisting}

\item Items \\
Return a (dict)tuple containing every keys associated to their values that are into you dictionnary.
\begin{lstlisting}[language=Python]
both = dictionnaire.items()
# dict_items([('nom', 'Jerome'), ('age', 20)])
\end{lstlisting}
\item Merge two dicts \\
You are able to merge two dicts in a single one. If some keys are repeated, it's the last one that is gonna overwrite.
\begin{lstlisting}[language=Python]
x = {'a':1, 'b':2}
y = {'c':3, 'a':4}
z = {**x,**y} # {'c':3, 'b':2, 'a':4}
\end{lstlisting}
\end{itemize}


\subsubsection{Set}
A set is a container that are very useful for mathematical operations\\
Here are some methods that you can apply on sets : 
\begin{itemize}
\item
\end{itemize}

\subsection{Containers}
Containers are any object that holds an arbitrary number of other objects. Generally, containers provide a way to access the contained objects and to iterate over them. We can find lists, strings, dicts, tuples and sets. Look out for mutability / immutability, some methods aren't possible between each other. \\

\subsubsection{Slicing}
Slicing is a method that concerns containers, you can use slicing on every possible container. \textbf{[start:end:step]} \textit{end argument isn't take in account : [start:end[}
\begin{itemize}
    \item Last element \\
    If you don't know the length of a certain container, you can access to the last element with slicing.
    \begin{lstlisting}[language=Python]
    dernier_elem = tableau[-1]
    # dlrow!
    \end{lstlisting}
    
    \item Trunc \\
    You can also trunc your list to keep just what you need.
    \begin{lstlisting}[language=Python]
    first_part = tableau[:3]
    second_part = tableau[3:]
    # first_part : ['Hello,', 'dlrow!Hello,', 'dlrow!Hello,'] and second_part : ['dlrow!']
    \end{lstlisting}
    
    \item Insert \\
    If you need to precisely insert an element into list, slicing is a good way of doing it.
    \begin{lstlisting}[language=Python]
    tableau[1:1] = 'A'
    # ['Hello,', 'A', 'dlrow!Hello,', 'dlrow!Hello,', 'dlrow!']
    \end{lstlisting}
    
    \item Reverse \\
    If you need to reverse your container you can also use slicing.
    \begin{lstlisting}[language=Python]
    tableau[::-1]
    # ['dlrow!', 'dlrow!Hello,', 'dlrow!Hello,'; 'A', 'Hello,']
    \end{lstlisting}
\end{itemize}

\subsubsection{Empty}
Sometimes you need to know if a container is empty. There are two common way to do it :
\begin{lstlisting}[language=Python]
if not my_container:
    print("empty")

if len(my_container)==0:
    print("empty")
\end{lstlisting}

\subsubsection{Iterator / Iterable}
Iterable is an object, which one can iterate over. It generates an Iterator when passed to iter() method. \\
Iterator is an object, which is used to iterate over an iterable object using \_\_next\_\_() method. Iterators have \_\_next\_\_() method, which returns the next item of the object.
\begin{lstlisting}[language=Python]
class IteratorIterable:
    def __init__(self, n):
        self.n = n
        self.cur = 1
        
    def __iter__(self):
        return self
        
    def __next__(self):
        if self.cur == self.n+1:
            raise StopIteration
        else:
            ret = self.cur
            self.cur += 1 
            return ret
\end{lstlisting}

\subsubsection{For}
\label{subsec:For}
For loop are the most powerful way to work on containers in python.

\begin{itemize}
    \item Range
    Range allows user to loop a certain times. \textbf{range(start,end, step)}
    \begin{lstlisting}[language=Python]
    for x in range(2):
    	print(x)
    #0
    #1
    \end{lstlisting}
    
    \item Enumerate
    Enumerate is a very good way to work with for loop. You can access simultaneously to the element and it's position in a tuple.
    \begin{lstlisting}[language=Python]
    liste = ['a', 'b', 'c']
    for index, elem in enumerate(liste):
    	print(f"{elem} at position {index}")
    # a at position 0
    # b at position 1
    # c at position 2
    \end{lstlisting}
    
    \item Zip
    Zip is another loop method. You can combine multiple lists with the same length in the loop. 
    \begin{lstlisting}[language=Python]
    names = ["Peter Parker", "Clark Kent", "Wade Wilson", "Bruce Wayne"]
    heroes = ["Spiderman", "Superman", "Deadpool", "Batman"]
    universes = ["Marvel", "DC", "Marvel", "DC"]
    
    for name, hero, universe in zip(names, heroes, universes):
    	print(f"{name} is actually {hero} from {universe}")
    	
    # Peter Parker is actually Spiderman from Marvel
    # Clark Kent is actually Superman from DC
    # Wade Wilson is actually Deadpool from Marvel
    # Bruce Wayne is actually Batman from DC
    \end{lstlisting}
\end{itemize}

\newpage
\section{Function}
\label{sec:Function}
A function is a block of organized, reusable code that is used to perform a single, related action. Functions provide better modularity for your application and a high degree of code reusing.\newline

\subsection{Lambda function}
\label{subsec:Lambda}
Lambda function are very small function, it's very simple to create them and very often better than a function. \textbf{function\_name = lambda parameter : return\_value}
\begin{lstlisting}[language=Python]
def equivalent_lambda(x):
	return x+5
	
real_lambda = lambda x : x+5

# equivalent_lambda : 10 and real_lambda : 10
\end{lstlisting}

\subsection{Default parameters}
Default parameters are used for parameters that don't necessarily need a value. We assign a default value that can be overloaded if needed. Default parameters are always declared after non-default parameters into function's head. \textbf{def func(non\_default\_parameters, \textit{default\_parameters = value})}

\begin{lstlisting}[language=Python]
def func(age, nom="Jerome"):
	print(f"Tu as {age} ans et tu t'appelles {nom}")

func(20, "Antoine")
func(20)
# Tu as 20 ans et tu t'appelles Antoine
# Tu as 20 ans et tu t'appelles Jerome

\end{lstlisting}

\subsection{Map function}
Map function is a special function used to apply a function for each element of a container. \textbf{map(function\_to\_apply, list)}
\begin{lstlisting}[language=Python]
liste = [1,2,3]
def map_function(x):
	return x**x
mapped_list = list(map(map_function,liste)) #No () for argument function

# before : [1, 2, 3] and now : [1, 4, 27]
\end{lstlisting}

\subsection{Filter function}
Filter function is a special function used to apply a selection for each element of a container. \textbf{map(function\_to\_apply, list)}
\begin{lstlisting}[language=Python]
liste = [1,2,3]
def filter_function(x):
	return x%2!=0
filtered_list = list(filter(filter_function,liste))

# before : [1, 2, 3] and now : [1, 3]
\end{lstlisting}

\subsection{List Comprehension}
List comprehension is probably one of the most powerful method that you can apply. It conbines map and filter function into a single way to do it. \textbf{[func\_to\_apply() for elem in list if filter\_condition]}
\label{subsec:ListComprehension}
\begin{lstlisting}[language=Python]
liste = [1,2,3]
new_list = [map_function(x) for x in liste if x%2!=0]

#before : [1, 2, 3] and now : [1, 27]
\end{lstlisting}

\subsection{Unknown parameters}
Sometimes you don't know how many arguments a function is going to receive. Also, it's important to handle unknown parameters. \textit{It's the case for exemple with the print() function}. \textbf{* means unnamed parameters and ** means named parameters}
\begin{lstlisting}[language=Python]
def parameters(*args, **kwargs):
	print(f"I received these unnamed args : {args}")
	print(f"I received these named args : {kwargs}")
parameters(1,"azerty",[1,2], couleur="rouge", taille_en_cm=172)
both
# I received these unnamed args : (1, 'azerty', [1, 2])
# I received these named args : {'couleur': 'rouge', 'taille_en_cm': 172}
\end{lstlisting}

\newpage
\section{Class}
\label{sec:Class}
Classes are a way of bringing together data and functionality. Creating a new class creates a new type of object and so new instances of this type can be built.\newline

\subsection{Instance}
Each instance can have its own attributes, which defines its state. An instance can also have methods (defined by the instance class) to modify its state.
\begin{lstlisting}[language=Python]
class MyClass(object):
	def __init__(self):
		pass

my_instance = MyClass()
\end{lstlisting}

\subsection{Methods}
Methods are functions that bellow to the class. A method can be used by the instance as follow  : \textbf{my\_instance.my\_method()}
\begin{lstlisting}[language=Python]
class MyClass(object):
	def __init__(self):
		pass
	def my_first_method(self):
	    print("hello")
	def my_second_method(self):
	    print("world")

my_instance = MyClass()
my_instance.my_second_method()
\end{lstlisting}

\subsection{Inheritance}
Inheritance is a concept of relation between classes. Some are parents, the other are children. A children inherit from every methods from the parent class but can overload them. A child class can have multiple parents.
\begin{lstlisting}[language=Python]
class Dog(object):
	def __init__(self, age):
		self.age = age
	def speak(self):
		print("Waf")
class Cat(Dog, Animal): #multiple inheritance
	"""Cat herite de Dog : elle possede ses fonctions et methodes"""
	def __init__(self, age, nom):
		super().__init__(age)
		self.nom = nom
	def speak(self):
		print("Miaou")
\end{lstlisting}

\subsection{Dunder methods}
Dunder methods are specific function from a class, they are surrounded by \_\_. A dunder method can be used by the instance as follow :\\ \textbf{my\_instance.\_\_dunder\_method\_\_}
\begin{lstlisting}[language=Python]
class Point(object):
	def __init__(self, x=0,y=0):
		self.x = x
		self.y = y
		self.conteneur = [1,2,3,4,5,6,7]

	def __str__(self):
		print("I'm the class Point")

	def __add__(self, p):
		"""la fonction add surcharge l'operateur +"""
		return Point(self.x + p.x, self.y + p.y)

#	def __getattr__(self, name):
#		print(f"{name} didn't found")

	def __setattr__(self, name, value):
		"""On modifie la classe mere directement plutot que seulement appeler setaatr de cette classe et tourner en boucle sur la meme methode"""
		object.__setattr__(self, name, value) #Chaque classe cree herite de base de la classe object

	def __delattr__(self, name):
		print(f"Deleting {name} ...")

	def __getitem__(self, index):
		return self.conteneur[index]

	def __setitem__(self, index, value):
		self.conteneur[index] = value

	def __contains__(self, value): # 8 in ma_liste  <==>  ma_liste.__contains__(8)
		return True if value in self.conteneur else False

	def __len__(self):
		return len(self.conteneur)

	"""Autres surcharges : 

	__sub__(self,p) : -
	__mul__(self,p) : *
	__truediv__(self, p) : /
	__floordiv__(self, p) : //
	__mod__(self, p) : %
	__pow__(self, p) : **

	__gt__(self,p)  : >
	__ge__(self,p) 	: >=
	__lt__(self,p)  : <
	__le__(self,p)  : <=
	__eq__(self,p) : == 

	__iadd__(self,p) : +=
	__isub__(self,p) : -=
	__imul__(self,p) : *=
	__itruediv__(self, p) : /=	
	...
	"""
\end{lstlisting}

\subsection{Static and class methods}
Static methods have a link with the class but don't use any attribute from it. There is no \textbf{self} in the parameters. \\
Class methods concerns class variables. There is no \textbf{self} in the parameters but \textbf{cls}.
\begin{lstlisting}[language=Python]
class StaticClass:
	nb_class=0
	def __init__(self):
		print("une nouvelle classe vient d'etre creee")
		nb_class+=1
	
	@classmethod
	def ma_func(cls): #pas de self, obligatoirement cls
		"""Agit avec les variables de la classe"""
		return cls.nb_class

	@staticmethod
	def ma_func2(arg1, arg2):#pas de self
		"""N'agit pas avec les composants de la classe mais est quand meme en lien avec la classe"""
		return arg1 + arg2
\end{lstlisting}

\subsection{Property}
Property concerns the private and public aspect from a class even though everything is public in python. In python, a variable or method which start with \_ is considered as "private". Also, we need to create getters and setters to access and modify these privates elements. Property redirect calls of privates elements to these getters and setters.
\begin{lstlisting}[language=Python]
"""
Property : permet d'offrir des accesseurs et mutateurs pour definir un attribut prive

La methode donnant acces a l'attribut

La methode modifiant l'attribut

La methode appelee quand on souhaite supprimer l'attribut (optionnel)

La methode appelee quand on demande de l'aide sur l'attribut (optionnel)

"""
class Test(object):
	def __init__(self, x=0, y=0):
		self.x = x
		self.y = y
		self._dimension = 2 #Attribut prive

	def _get_dimension(self):
		return self._dimension

	def _set_dimension(self,value):
		self._dimension = value
		
	dimension = property(_get_dimension, _set_dimension) # lorsqu'on appelera objet.dimension, property redirigera vers les accesseurs/mutateurs prives
\end{lstlisting}

\subsection{Metaclass}
Every class inherit from the \textit{object} class, metaclass is a way to define how to create our own classes without inheriting from \textit{object}.

\subsection{Other}
In python, everything is public so there isn't any private method or variable from a class. We can use \_ to tell to the user that we want it private even though it's not really.

In classes you can use self.\_\_my\_private\_attr = "I'm private" 
It's called name scrambling and it is used to ensure that subclasses don't accidentally override the private methods and attributes of their superclasses. It's not designed to prevent deliberate access from outside. We can see it with : my\_instance.\_\_dict\_\_

There are some tips useful to know concerning class :
\begin{lstlisting}[language=Python]
print(dir(ma_instance)) #return a list of every dunder methods, methods and attributes from the class.
print(ma_instance.__dict__) # return a dict with attributes as keys and their value. associated.
print(issubclass(child_class, parent_class)) # return True if child_class is the child of parent_class.
print(isinstance(my_instance, my_class)) # return True if my_instance is an instance from my_class.
\end{lstlisting}

\newpage
\section{Decorators}
A decorator is a design pattern in Python that allows a user to add new functionality to an existing object without modifying its structure. Decorators are usually called before the definition of a function you want to decorate. \textbf{@my\_decorator}\newline
\subsection{Function}
A decorator can be applied to wrap a function and apply a process on it each time it's called.
\begin{lstlisting}[language=Python]
import time
def timer(func):
	def wrapper(*args, **kwargs):
		start = time.time()
		rv = func(*args, **kwargs)
		total = time.time() - start
		print("Time to execute : "+ str(total))
		return rv
	return wrapper

@timer #we can chain decorators
def exemple(x):
	return "je suis "+str(x)
	
exemple(5)
#Time to execute : 2.384185791015625e-06
#je suis 5
\end{lstlisting}

\subsection{Class}
A decorator can also be used to wrap a class.

\subsection{Multiple decorators}
You can chain decorators to apply multiple processes on the same function / class.

\newpage
\section{Generators}
\label{sec:Generators}
Generators are simple and powerful tools for creating iterators. They are written like regular functions but use the yield statement when they want to return data. Each time it is called by next (), the generator resumes execution where it left off (keeping all of its execution context).\newline
\subsection{Iterators}
\subsection{Yield}

\newpage
\section{Modules}
Modules are Python programs that contain functions that we often reuse (we also call them libraries or libraries). These are “toolboxes” that will be very useful to you.\newline

\subsection{Import}
\label{subsec:Import}
\subsubsection{Import module from another repertory}
Sometimes you need to import a module that isn't into you actual repertory, rather than copy this module into you repertory you can import it by another way. \\

Tree exemple : \\
Main/ \\
....main.py \\
....Test/ \\
........test.py \\

\begin{lstlisting}[language=Python]
import sys
sys.path.append("./Test")
import test # .py file (module)
\end{lstlisting}

\subsubsection{Import module as}
Sometimes you import modules but it's very long to write methods from a long module name. Plus, it's not good to use the \textit{import * from module} because it can creates conflicts between function and class that have the same name in two different modules. Rather than writing module.class you can use the key word \textbf{as}. It very used for libraries like numpy as np, matplotlib.pyplot as plt and scipy.signal as sig
\label{As}

\subsection{Time}
\subsubsection{Time}
For further explanations, see the \href{https://docs.python.org/3/library/time.html}{official documentation}

\subsubsection{Datetime}
For further explanations, see the \href{https://docs.python.org/3/library/datetime.html}{official documentation}

\subsection{Password}

\subsubsection{Getpass}
Get pass is a very useful module to enter password secretly. In deed, it doesn't show the characters entered.
\begin{lstlisting}[language=Python]
mdp getpass.getpass("Type your password : ")
\end{lstlisting}

For further explanations, see the \href{https://docs.python.org/3/library/getpass.html}{official documentation}

\subsubsection{Hashlib}
For further explanations, see the \href{https://docs.python.org/3/library/hashlib.html}{official documentation}


\subsection{Os}
\subsubsection{Working repertory}
You can get you actual working repertory by using :
\begin{lstlisting}[language=Python]
my_repertory = os.getcwd()
\end{lstlisting}

\subsubsection{Terminal commandline}
You can run terminal commandlines by using : (look out for commands that corresponds with the os terminal you are running you program in)
\begin{lstlisting}[language=Python]
os.system("ls")

#get the value returned with
cmd = os.popen("ls")
cmd.read()
\end{lstlisting}

\subsection{Sys}
\subsubsection{Memory used by a variable}
Control you memory while programming. 
\begin{lstlisting}[language=Python]
var = [1]*100
print(f"memoire utilisee par var : {sys.getsizeof(var)} bytes") #memoire utilisee par var : 856 bytes
\end{lstlisting}

\subsubsection{Redirect flow}
We can redirect the flow to write directly somewhere instead of the terminal.
\begin{lstlisting}[language=Python]
file = open("output.txt", 'w')
sys.stdout = fichier # return to original flow with sys.__stdout__
\end{lstlisting}

\subsubsection{Exit program}
You can exit the program any time you want when it's running. The parameter inside the function is important to specify to the user is there has been a problem or not; 0 means no problem and anything else (often 1) means that there has been a problem.
\begin{lstlisting}[language=Python]
sys.exit(parameter)
\end{lstlisting}

\subsubsection{Get parameters passed in the call}
You can get any parameter specified by the user when he runned the program. (if an parameter is separated by space(s), sourround him by "").
\begin{lstlisting}[language=Python]
sys.argv
\end{lstlisting}

\subsection{Math}
For further explanations, see the \href{https://docs.python.org/3/library/math.html}{official documentation}

\subsection{Random}
For further explanations, see the \href{https://docs.python.org/3/library/random.html}{official documentation}

\subsection{Argparse}
You can parse argument(s) passed in the call of program using argparse.
\begin{lstlisting}[language=Python]
parser = argparse.ArgumentParser()

#add instruction when user type program.py --help/-h
#imagine we need an compulsory argument of type int :
parser.add_argument("x", type=int, help="description of x")
#imagine that the user can specify an other optional argument:
parser.add_argument("-v", "--verbose", action="store_true", help="add more explanation")

#save arguments
args = parser.parse_args()

#get args
print(args.x)
if args.verbose:
    print("I add more explanations")
\end{lstlisting}
For further explanations, see \href{http://www.sharelatex.com}{argparse tutorial} or  \href{https://docs.python.org/3/library/argparse.html}{official documentation}.


\subsection{Unittest}
For further explanations, see the \href{https://docs.python.org/3/library/unittest.html}{official documentation}


\subsection{Re}
Regex also known as regular expression is a very powerfull module for searching in string. \textbf{re.search(expression, string)} with \textbf{expression = r"..."} \\

\begin{table}[h]
\begin{center}
{\renewcommand{\arraystretch}{2} %donne la distance entre les lignes%
{\setlength{\tabcolsep}{1.5cm} %donne la distance entre les collones%
\begin{tabular}{|l|c|r|}
  \hline
  \makecell{$\land$ \\ start} & \makecell{* \\ 0,1,...} & \makecell{\{\} \\ n times} \\
  \hline
  \makecell{\$ \\ end} & \makecell{+ \\ 1,...} & \makecell{[] \\ sth inside} \\
  \hline
  \makecell{? \\ 0 or 1} & \makecell{() \\ group} &  \\
  \hline
\end{tabular}}}
\end{center}
\caption{Regex methods}
\end{table}

Example :
\begin{lstlisting}[language=Python]
# I want to find a phone number with digits separated by a space, a point or an hyphen.
expression = r"^0[0-9]([ .-]?[0-9]{2}){4}$"
# I want a password with at least 6 characters and containing number or letter or both.
expression = r"^[A-Za-z0-9]"
\end{lstlisting}

See more explanation about re on the \href{https://docs.python.org/3/library/re.html?highlight=re#module-re}{official documentation}

\subsection{Cx\_freeze / setup}
You can create .exe program that anybody can run on its own computer without having python or the extern libraries installed by using the module cx\_Freeze. \\
You can do the same by creating a setup.py file. \\

See more explanation about cx\_Freeze on the  \href{https://cx-freeze.readthedocs.io/en/latest/}{official documentation}


\subsection{Reseau}
\subsubsection{Socket}
For further explanations, see the \href{https://docs.python.org/3/library/socket.html}{official documentation} and socketserver  \href{https://docs.python.org/3/library/socketserver.html}{official documentation} 
\subsubsection{Select}
For further explanations, see the \href{https://docs.python.org/3/library/select.html}{official documentation}

\subsection{Threads}
For further explanations, see the \href{https://docs.python.org/3/library/threading.html}{official documentation}


\subsection{Inspect}
If you're interested in knowing how a class is built you can use the inspect module. It prints out the full code from the class. You can't use this function on built-in module like math, os, ... because it's not written in python.
\begin{lstlisting}[language=Python]
import inspect
from queue import Queue
print(f"Code source : \n{inspect.getsource(Queue)}")
\end{lstlisting}

\newpage
\section{Toolbox}
\subsection{Break / Continue / Pass / Return}
\label{subsec:BCPR}
\begin{lstlisting}[language=Python]
#pass is similar to an empty instruction.
if True:
    pass

#return is used in function to give a response to a call.
def func():
	"""this is a docstring, use help(func) to know more about this function."""
	return "j'ai retourne une phrase"

#break and continue are used in loop to modify the way the loop is looping.
nb = 3
while nb != 20:
	if nb>6:
		break #End the loop
	nb+=1
	if nb==5:
		continue #Go to the top of the loop without executing the rest.	
	print(nb)

#4
#6
#7
\end{lstlisting}

\subsection{Context manager}
\label{subsec:ContextManager}

\subsection{Global variables}
\label{subsec:Global}
Variables that are created outside of a function (as in all of the examples above) are known as global variables.\\
Global variables can be used by everyone, both inside of functions and outside.
\begin{lstlisting}[language=Python]
a = b = 5
#a = 5 et b = 5
def modify(b):
	global a #modify the variable outside the function
	a*=2
	b*=2

modify(b)
#a = 10 et b = 5
\end{lstlisting}

\subsection{Exception}
In python you can handle exceptions that may occur when your program is running. \textit{We can always use \textbf{except Exception as e} but it's better to be the most precise possible.}
\subsubsection{Try / Except / Else / Finally}
This is the basic structure to handle exception :
\label{TEEF}
\begin{lstlisting}[language=Python]
nom = "Jerome"
try:
	key = int(nom)
except ValueError:
	print("Votre nom ne peut pas etre convertit en integer")
else: #done if try is ok
	print("Key as been validated")
finally: #always done
	print("end ...")
	
#Votre nom ne peut pas etre convertit en integer
#end ...
\end{lstlisting}

We can also create our own exception by creating a new class.
\begin{lstlisting}[language=Python]
#Creer notre propre exception : La methode __str__ de la classe est ce qui est appele pour afficher le message d'erreur
class MonException(Exception):
    """Exception levee dans un certain contexte qui reste a definir"""
    def __init__(self, message):
        """On se contente de stocker le message d'erreur"""
        self.message = message
    def __str__(self):
        """On renvoie le message"""
        return self.message
\end{lstlisting}

\subsubsection{Raise}
\label{Raise}
If you want to personalize the way a process handle exceptions you can use the \textbf{raise} keyword.


\subsubsection{If / Elif / Else}
\label{IEE}
You can write if / else conditions in an easy way in python :
\begin{lstlisting}[language=Python]
condition = False

#Bad way :
if condition:
	x=1
else:
	x=0
	#0

#Good way :
x = 1 if condition else 0
#0
\end{lstlisting}

\subsection{Files}

\subsection{// and **}
There are two basics operations in python very useful instead of using a math method.
\begin{lstlisting}[language=Python]
print(f"10 / 3 = {10 / 3}") # 10 / 3 = 3.3333333333333335
print(f"10 // 3 = {10 // 3}") # 10 // 3 = 3

print(f"3**3 = {3**3}"}) # 3**3 = 9
\end{lstlisting}

\subsection{Assertion}
\label{subsec:Assertion}
You can verify a condition before parsing an information by checking the instance type.
\begin{lstlisting}[language=Python]
b = 3
assert isinstance(b, int)
\end{lstlisting}

\subsection{Cast}
Sometimes you need to convert a variable from a certain type to another. Cast is a good way to do it but you've to know that you can lose information by doing it. \\ \\
You can do it by simply follow this pattern : \textbf{new\_type(my\_variable)}
Notice that you have to be coherent in your type transformation. For example, you won't be able to cast a string into an integer if your string = "Salut".

\subsection{Encoding}
You can precise in the first line of your .py document the encoding your are curently using.
\begin{lstlisting}[language=Python]
# -*-coding:Utf-8 -*
\end{lstlisting}

\subsection{Path}
You can precise path to your python compilator in the second line of your .py document.
\begin{lstlisting}[language=Python]
# !/usr/bin/python3.8
\end{lstlisting}

\subsection{Test the validity of several values}
You can check if one of several values is not False.
\begin{lstlisting}[language=Python]
x,y,z = 0,1,0
if 1 in (x,y,z):
    pass
if x or y or z:
    pass
if any((x,y,z)):
    pass
\end{lstlisting}

\subsection{Encoding}
It's possible to encode a string into bytes using a special string methods. You have to put a b for bytes in front of the first " of you string. Another way is to use encode function as my\_string.encode()

\end{document}
