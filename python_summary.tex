\documentclass[a4paper, 12pt, titlepage]{scrartcl} %document type
\usepackage[utf8]{inputenc} %encoding
\usepackage[T1]{fontenc}    
\usepackage[english]{babel} %language

\usepackage{graphicx}

\titlehead{\centering\includegraphics[width=6cm]{python}}
\title{python\_summary}
\author{}
\date{August 14, 2020 - \today}
\publishers{Ewan Carree}

%manage cells in tables
\usepackage{makecell}

%manage colors
\usepackage{xcolor}
%\usepackage{color}

%New colors defined below
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% add code
\usepackage{listings}
%Code listing style named "mystyle"
\lstdefinestyle{mystyle}{
  backgroundcolor=\color{backcolour},   commentstyle=\color{codegray},
  keywordstyle=\color{magenta},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{black},
  basicstyle=\ttfamily\footnotesize,
  breakatwhitespace=false,         
  breaklines=true,                 
  captionpos=b,                    
  keepspaces=true,                 
  numbers=left,                    
  numbersep=5pt,                  
  showspaces=false,                
  showstringspaces=false,
  showtabs=false,                  
  tabsize=4
}
%"mystyle" code listing set
\lstset{style=mystyle}

%\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry} 

%extern and intern links
\usepackage{hyperref} %links
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    urlcolor=blue,
    linktoc=all
}

\iffalse % start ignore code
%Python code highlighting
\begin{lstlisting}[language=Python]

\end{lstlisting} \vspace{5mm}
\fi % end ignore code







\begin{document}

\maketitle
\newpage

\tableofcontents

\newpage
\section{Python reserved words}
In python 3, there are some reserved words that you can't use in your program as variables, function name, class name, ... \\ \\ \\

\begin{table}[h]
\begin{center}
{\renewcommand{\arraystretch}{2} %donne la distance entre les lignes%
{\setlength{\tabcolsep}{1.5cm} %donne la distance entre les collones%
\begin{tabular}{|l|c|r|}
  \hline
  \hyperref[subsec:Bool]{False} & None & \hyperref[subsec:Bool]{True} \\
  \hline
  and & \hyperref[As]{as} & \hyperref[subsec:Assertion]{assert} \\
  \hline
  \hyperref[subsec:BCPR]{break} & \hyperref[sec:Class]{class} & \hyperref[subsec:BCPR]{continue} \\
  \hline
  \hyperref[sec:Function]{def} & del & \hyperref[IEE]{elif} \\
  \hline
  \hyperref[IEE]{else} & \hyperref[TEEF]{except} & \hyperref[TEEF]{finally} \\
  \hline
  \hyperref[subsec:For]{for} & from & \hyperref[subsec:Global/Nonlocal]{global} \\
  \hline
  \hyperref[IEE]{if} & \hyperref[subsec:Import]{import} & \hyperref[Comprehension]{in} \\
  \hline
  \hyperref[subsec:Is]{is} & \hyperref[subsec:Lambda]{lambda} & \hyperref[subsec:Global/Nonlocal]{nonlocal} \\
  \hline 
  not & or & \hyperref[subsec:BCPR]{pass} \\
  \hline 
  \hyperref[Raise]{raise} & \hyperref[subsec:BCPR]{return} & \hyperref[TEEF]{try} \\
  \hline
  while & \hyperref[subsec:ContextManager]{with} & \hyperref[sec:Generators]{yield} \\
  \hline
\end{tabular}}}
\end{center}
\caption{Reserved words}
\end{table}



\clearpage
\section{Types}
Python offers different basics types that are often enough for your program.\newline

\subsection{Immutable}
Immutable means that you can't directly modify your variable after you've assigned it. You have to reassign or create a new variable to work on a previous one\newline

\subsubsection{String}
Python string is an ordered collection of characters which is used to represent and store the text-based information. Strings are stored as individual characters in a contiguous memory location. It can be accessed from both directions: forward and backward. A string can be seen in some ways as a list of characters. \\It's better to use ' for as single character and " for a chain. \\ \\
Here are some methods that you can apply on strings (I choose to reassign the variable whenever it's possible) : 
\begin{itemize}
\begin{lstlisting}[language=Python]
string = "Hello, world!"
\end{lstlisting} \vspace{5mm}

\item Upper case \\
Return a string with every single element from the original one in uppercase.
\begin{lstlisting}[language=Python]
string = string.upper()
# HELLO, WORLD!
\end{lstlisting} \vspace{5mm}

\item Lowercase \\
Return a string with every single element from the original one in lowercase.
\begin{lstlisting}[language=Python]
string = string.lower()
# hello, world!
\end{lstlisting} \vspace{5mm}

\item Captital \\
Return a string with the first Letter in uppercase and the rest in lowercase.
\begin{lstlisting}[language=Python]
string = string.capitalize()
# Hello, world!
\end{lstlisting} \vspace{5mm}

\item Strip \\
Return a string whithout the blank spaces from both sides of the original string.
\begin{lstlisting}[language=Python]
string = string.strip()
\end{lstlisting} \vspace{5mm}

\item Find \\
Return an integer which is the position of the first argument found in the string from left to right.
\begin{lstlisting}[language=Python]
position = string.find('l')
# 2
\end{lstlisting} \vspace{5mm}

\item Count \\
Return an integer that represents the number of occurences of the argument found in the string. 
\begin{lstlisting}[language=Python]
nb = string.count('l')
# 3
\end{lstlisting} \vspace{5mm}

\item Replace \\
Return a string where at least a part of it have been replaced by some another words.
\begin{lstlisting}[language=Python]
string = string.replace("world", "dlrow")
# Hello, dlrow!
\end{lstlisting} \vspace{5mm}

\item Multiply \\
Return a string with n times the original string.
\begin{lstlisting}[language=Python]
string = string*3
# Hello, dlrow!Hello, dlrow!Hello, dlrow!
\end{lstlisting} \vspace{5mm}

\item String to List \\
Transform your string into a list.
\begin{lstlisting}[language=Python]
tableau = string.split(' ')
# ['Hello,', 'dlrow!Hello,', 'dlrow!Hello,', 'dlrow!']
\end{lstlisting} \vspace{5mm}

\item Fill \\
Return a string filled with zero to correspond to have the same digit in every number.
\begin{lstlisting}[language=Python]
string = '5'
string = string.zfill(3)
# 005
\end{lstlisting} \vspace{5mm}

There is another way of doing it while printing argument with \hyperref[subsec:F-string]{F-string}.
\end{itemize}

\subsubsection{Integer}
You can write very long number in a more readable way with \_ : 
\begin{lstlisting}[language=Python]
nb = 1_000_000
# 1000000
\end{lstlisting} \vspace{5mm}

\subsubsection{Float}
You can handle decimal to choose how many decimal you need. You can modify it by two different ways : 
\begin{lstlisting}[language=Python]
my_float = 3.3333333
print("%.0f" % my_float + "with no decimal and " + "%.2f" % my_float + "with two decimals") #3 with no decimal and 3.33 with two decimals
round(my_float, 3) # 3.333
\end{lstlisting} \vspace{5mm}

There is another way of doing it while printing argument with \hyperref[subsec:F-string]{F-string}.

\subsubsection{Tuple}
A tuple is a container that can contain multiple variables with multiple types that have a link together. \\
\begin{itemize}
\item Unpack \\
You can unpack each variable from a tuple very easily in python as follow \textbf{first\_variable, ..., n\_variable = my\_tuple\_with\_n\_variable}
\begin{lstlisting}[language=Python]
my_tuple = (1,2)

#unpack :
a, b = my_tuple #1 and 2
\end{lstlisting} \vspace{5mm}

\item Ignore unpacked variables \\
When you unpack tuple arguments, sometimes some argument aren't useful, the common way to write it is with \_
\begin{lstlisting}[language=Python]
my_tuple = (1,2)
my_tuple2 = (1,2,3,4,5)

#We don't need b :
a, _ = my_tuple #1

#Another example :
for _ in range(2):
	print("I don't care about i")
#I don't care about i
#I don't care about i

#Another example :
a, b, *_ = my_tuple2 #We ignore everything after the first two variables, the rest is stored in a list.
a, b, *c, d = my_tuple2 
print(f"{a}, {b}, {c}, {d}") #1, 2, [3, 4], 5
\end{lstlisting} \vspace{5mm}

\item Named tuple \\
To name your tuple is a way to create a much more clear code for someone who read your code. For example, an unnamed tuple doesn't give that much information on what it contains.
\begin{lstlisting}[language=Python]
from collections import namedtuple

Color = namedtuple("Color", ["red", "green", "blue"])

white = Color(255,255,255)

print(white.red) # we can also call like basic tuple with white[0]
# 255
\end{lstlisting} \vspace{5mm}
\end{itemize}


\subsubsection{Bool}
\label{subsec:Bool}
There is only two types of Boolean : True and False. \\
Everything can be considered as True if it different from 0 or False. \\
\begin{lstlisting}[language=Python]
a = "Salut"
b = 0
if a:
	print("a fonctionne")
	# a fonctionne
else:
	print("a ne fonctionne pas")

if b:
	print("b fonctionne")
else:
	print("b ne fonctionne pas")
	# b ne fonctionne pas
\end{lstlisting} \vspace{5mm}

\subsection{Mutable}
Mutable means that if you are working on a variable, you directly modify it and don't need to create a new variable or reassign the previous one. It can cause conflict if two process are using the same variable that can be changed.\newline

\subsubsection{List}
A list is a container that can contain multiple variables with multiple types that have a link together.\\ \\
Here are some methods that you can apply on lists : 

\begin{lstlisting}[language=Python]
tableau = ['Hello,', 'dlrow!Hello,', 'dlrow!Hello,', 'dlrow!']
\end{lstlisting} \vspace{5mm}

\begin{itemize}
\item Add \\
You can merge two lists into single one containing elements from both original lists.
\begin{lstlisting}[language=Python]
new_tab = first_part + second_part
# ['Hello,', 'dlrow!Hello,', 'dlrow!Hello,', 'dlrow!']
\end{lstlisting} \vspace{5mm}

\item Multiply \\
Just like a string, you can multiply your list.
\begin{lstlisting}[language=Python]
multilpied_new_tab = new_tab *3
# ['Hello,', 'dlrow!Hello,', 'dlrow!Hello,', 'dlrow!', 'Hello,', 'dlrow!Hello,', 'dlrow!Hello,', 'dlrow!', 'Hello,', 'dlrow!Hello,', 'dlrow!Hello,', 'dlrow!']
\end{lstlisting} \vspace{5mm}

\item Index \\
Return an integer which correspond to the position of the element searched.
\begin{lstlisting}[language=Python]
position = tableau.index('A')
# 1
\end{lstlisting} \vspace{5mm}

\item Range \\
You can initialize a list of n ascending numbers easily with : 
\begin{lstlisting}[language=Python]
my_list = list(range(n))
\end{lstlisting} \vspace{5mm}

\item List to String \\
Transfrom your list into a string.
\begin{lstlisting}[language=Python]
string = ' '.join(tableau)
# Hello, A dlrow!Hello, dlrow!Hello, dlrow!
\end{lstlisting} \vspace{5mm}
\end{itemize}

\subsubsection{Dict}
A dict is an non-organized container that have variables associated to keys to recognize them. Keys are offently strings but we can also use integers.\\ \\
Here are some methods that you can apply on dicts : 
\begin{lstlisting}[language=Python]
dictionnaire = {"nom":"Jerome", "age":20}
\end{lstlisting} \vspace{5mm}

\begin{itemize}
\item Keys \\
Return a (dict)list containing every keys that are into you dictionnary.
\begin{lstlisting}[language=Python]
keys = dictionnaire.keys()
#dict_keys(['nom', 'age'])
\end{lstlisting} \vspace{5mm}

\item Values \\
Return a (dict)list containing every values that are into you dictionnary.
\begin{lstlisting}[language=Python]
keys = dictionnaire.keys()
#dict_values(['Jerome', 20])
\end{lstlisting} \vspace{5mm}

\item Items \\
Return a (dict)tuple containing every keys associated to their values that are into you dictionnary.
\begin{lstlisting}[language=Python]
both = dictionnaire.items()
# dict_items([('nom', 'Jerome'), ('age', 20)])
\end{lstlisting} \vspace{5mm}
\item Merge two dicts \\
You are able to merge two dicts in a single one. If some keys are repeated, it's the last one that is gonna overwrite.
\begin{lstlisting}[language=Python]
x = {'a':1, 'b':2}
y = {'c':3, 'a':4}
z = {**x,**y} # {'c':3, 'b':2, 'a':4}
\end{lstlisting} \vspace{5mm}
\end{itemize}


\subsubsection{Set}
A set is a container that are very useful for mathematical operations.\\
It is similar to a list except the fact that there is only unique value in a set.
\begin{lstlisting}[language=Python]
my_list = [1,1,3,5,5]
my_set = set(my_list) # {1, 3, 5}
\end{lstlisting} \vspace{5mm}

Here are some methods that you can apply on sets : 
\begin{lstlisting}[language=Python]
my_set = {1,2} # impossible to init with {} because it's a dict but possible with set()
\end{lstlisting} \vspace{5mm}

\begin{itemize}
\item Add \\
Add allows us to add one single value to our set.
\begin{lstlisting}[language=Python]
my_set.add(3) # {1,2,3} 
\end{lstlisting} \vspace{5mm}

\item Update \\
Update allows us to add multiple values to our set. We can pass many arguments into the update() function like lists, other sets, ...
\begin{lstlisting}[language=Python]
my_set.update([4,5]) # {1,2,3,4,5}
\end{lstlisting} \vspace{5mm}

\item Remove \\
Remove allows us to remove one single value from our set. If the value doesn't exist, then it raises an error.
\begin{lstlisting}[language=Python]
my_set.remove(5) # {1,2,3,4}
\end{lstlisting} \vspace{5mm}

\item Discard \\
Discard allows us to remove one single value from our set. If the value doesn't exist, then it dosen't do anything. 
\begin{lstlisting}[language=Python]
my_set.discard(5) # {1,2,3,4}
\end{lstlisting} \vspace{5mm}

\item Pop \\
Pop allows us to remove one single element from our set but we don't know which one because sets are unordered data type, it's completely arbitrary.
\begin{lstlisting}[language=Python]
my_set.pop() # {1,3,4}
\end{lstlisting} \vspace{5mm}

\item Clear \\
Clear allows us to remove every item from our set.
\begin{lstlisting}[language=Python]
my_set.clear() # set()
\end{lstlisting} \vspace{5mm}
\end{itemize} \vspace{5mm}

As said before, sets are also very useful for math methods, here are some exemples of what we can do with them :

\begin{table}[h]
\begin{center}
{\renewcommand{\arraystretch}{2} %donne la distance entre les lignes%
{\setlength{\tabcolsep}{1.5cm} %donne la distance entre les collones%
\begin{tabular}{|c|c|}
  \hline
  \makecell{\makecell{ | \\ union()} \\ Union} & \makecell{\makecell{ \& \\ intersection()} \\ Intersection} \\
  \hline
  \makecell{\makecell{ - \\ difference()} \\ Difference} & \makecell{\makecell{ $\land$ \\ symmetric\_difference()} \\ Symmetric difference} \\
  \hline
\end{tabular}}}
\end{center}
\caption{Sets operations}
\end{table} \vspace{5mm}



\begin{lstlisting}[language=Python]
A = {1, 2, 3, 4, 5}
B = {4, 5, 6, 7, 8}
\end{lstlisting} \vspace{5mm}
\begin{itemize}
    \item Union \\
    Union of A and B is a set of all elements from both sets.
    \begin{lstlisting}[language=Python]
    A.union(B) # {1, 2, 3, 4, 5, 6, 7, 8}
    print(A | B) # {1, 2, 3, 4, 5, 6, 7, 8}\end{lstlisting} \vspace{5mm}
    
    \item Intersection \\
    Intersection of A and B is a set of elements that are common in both the sets.
    \begin{lstlisting}[language=Python]
    A.intersection(B) # {4, 5}
    print(A & B) # {4, 5}\end{lstlisting} \vspace{5mm}
    
    \item Difference \\
    Difference of the set B from set A(A - B) is a set of elements that are only in A but not in B. Similarly, B - A is a set of elements in B but not in A.
    \begin{lstlisting}[language=Python]
    A.difference(B) # {1, 2, 3}
    print(A - B) # {1, 2, 3}\end{lstlisting} \vspace{5mm}
    
    \item Symmetric difference \\
    Symmetric Difference of A and B is a set of elements in A and B but not in both (excluding the intersection).
    \begin{lstlisting}[language=Python]
    A.symmetric_difference(B) # {1, 2, 3, 6, 7, 8}
    print(A ^ B) # {1, 2, 3, 6, 7, 8}\end{lstlisting} \vspace{5mm}
    
\end{itemize}

\subsection{Containers}
Containers are any object that holds an arbitrary number of other objects. Generally, containers provide a way to access the contained objects and to iterate over them. We can find lists, strings, dicts, tuples and sets. Look out for mutability / immutability, some methods aren't possible between each other. \\

\subsubsection{Comprehension}
\label{Comprehension}
Container (list, dict, set) comprehension is probably one of the most powerful method that you can apply. It conbines map and filter function into a single way to do it. \textbf{[func\_to\_apply() for elem in container if filter\_condition]} \\

Example with lists :
\begin{lstlisting}[language=Python]
my_list = [1,2,3]
new_list = [x**x for x in my_list if x%2!=0]

#before : [1, 2, 3] and now : [1, 27]
\vspace{5mm}

Example with dicts :
\begin{lstlisting}[language=Python]
names = ["Peter Parker", "Clark Kent", "Wade Wilson", "Bruce Wayne"]
heroes = ["Spiderman", "Superman", "Deadpool", "Batman"]

my_dict = {name: hero for name, hero in zip(names, heroes) if name != "Peter Parker"}
# {'Clark Kent': 'Superman', 'Wade Wilson': 'Deadpool', 'Bruce Wayne': 'Batman'}
\end{lstlisting} \vspace{5mm}

Example with sets :
\begin{lstlisting}[language=Python]
my_list = [1,1,3,5,5]
my_set = {n for n in my_list} #{1,3,5}
\end{lstlisting} \vspace{5mm}

\subsubsection{Slicing}
Slicing is a method that concerns containers, you can use slicing on every possible container. \textbf{[start:end:step]} \textit{end argument isn't take in account : [start:end[}
\begin{itemize}
    \item Last element \\
    If you don't know the length of a certain container, you can access to the last element with slicing.
    \begin{lstlisting}[language=Python]
    dernier_elem = tableau[-1]
    # dlrow!
    \end{lstlisting} \vspace{5mm}
    
    \item Trunc \\
    You can also trunc your list to keep just what you need.
    \begin{lstlisting}[language=Python]
    first_part = tableau[:3]
    second_part = tableau[3:]
    # first_part : ['Hello,', 'dlrow!Hello,', 'dlrow!Hello,'] and second_part : ['dlrow!']
    \end{lstlisting} \vspace{5mm}
    
    \item Insert \\
    If you need to precisely insert an element into list, slicing is a good way of doing it.
    \begin{lstlisting}[language=Python]
    tableau[1:1] = 'A'
    # ['Hello,', 'A', 'dlrow!Hello,', 'dlrow!Hello,', 'dlrow!']
    \end{lstlisting} \vspace{5mm}
    
    \item Reverse \\
    If you need to reverse your container you can also use slicing.
    \begin{lstlisting}[language=Python]
    tableau[::-1]
    # ['dlrow!', 'dlrow!Hello,', 'dlrow!Hello,'; 'A', 'Hello,']
    \end{lstlisting} \vspace{5mm}
\end{itemize}

\subsubsection{Empty}
Sometimes you need to know if a container is empty. There are two common way to do it :
\begin{lstlisting}[language=Python]
if not my_container:
    print("empty")

if len(my_container)==0:
    print("empty")
\end{lstlisting} \vspace{5mm}

\subsubsection{Iterator / Iterable}
Iterable is an object, which one can iterate over. It generates an Iterator when passed to iter() method. \\
Iterator is an object, which is used to iterate over an iterable object using \_\_next\_\_() method. Iterators have \_\_next\_\_() method, which returns the next item of the object.
\begin{lstlisting}[language=Python]
class IteratorIterable:
    def __init__(self, n):
        self.n = n
        self.cur = 1
        
    def __iter__(self):
        return self
        
    def __next__(self):
        if self.cur == self.n+1:
            raise StopIteration
        else:
            ret = self.cur
            self.cur += 1 
            return ret
\end{lstlisting} \vspace{5mm}

\subsubsection{For}
\label{subsec:For}
For loop are the most powerful way to work on containers in python.

\begin{itemize}
    \item Range \\
    Range allows user to loop a certain times. \textbf{range(start,end, step)}
    \begin{lstlisting}[language=Python]
    for x in range(2):
    	print(x)
    #0
    #1
    \end{lstlisting} \vspace{5mm}
    
    \item Enumerate \\
    Enumerate is a very good way to work with for loop. You can access simultaneously to the element and it's position in a tuple.
    \begin{lstlisting}[language=Python]
    liste = ['a', 'b', 'c']
    for index, elem in enumerate(liste):
    	print(f"{elem} at position {index}")
    # a at position 0
    # b at position 1
    # c at position 2
    \end{lstlisting} \vspace{5mm}
    
    \item Zip \\
    Zip is another loop method. You can combine multiple lists with the same length in the loop. 
    \begin{lstlisting}[language=Python]
    names = ["Peter Parker", "Clark Kent", "Wade Wilson", "Bruce Wayne"]
    heroes = ["Spiderman", "Superman", "Deadpool", "Batman"]
    universes = ["Marvel", "DC", "Marvel", "DC"]
    
    for name, hero, universe in zip(names, heroes, universes):
    	print(f"{name} is actually {hero} from {universe}")
    	
    # Peter Parker is actually Spiderman from Marvel
    # Clark Kent is actually Superman from DC
    # Wade Wilson is actually Deadpool from Marvel
    # Bruce Wayne is actually Batman from DC
    \end{lstlisting} \vspace{5mm}
\end{itemize}

\newpage
\section{Function}
\label{sec:Function}
A function is a block of organized, reusable code that is used to perform a single, related action. Functions provide better modularity for your application and a high degree of code reusing.\newline

\subsection{Lambda function}
\label{subsec:Lambda}
Lambda function are very small function, it's very simple to create them and very often better than a function. \textbf{function\_name = lambda parameter : return\_value}
\begin{lstlisting}[language=Python]
def equivalent_lambda(x):
	return x+5
	
real_lambda = lambda x : x+5

# equivalent_lambda : 10 and real_lambda : 10
\end{lstlisting} \vspace{5mm}

\subsection{Default argument}
Default parameters are used for arguments that don't necessarily need a value. We assign a default value that can be overloaded if needed. Default arguments are always declared after non-default arguments into function's head. \textbf{def func(non\_default\_arguments, \textit{default\_arguments = value})}

\begin{lstlisting}[language=Python]
def func(age, nom="Jerome"):
	print(f"Tu as {age} ans et tu t'appelles {nom}")

func(20, "Antoine")
func(20)
# Tu as 20 ans et tu t'appelles Antoine
# Tu as 20 ans et tu t'appelles Jerome
\end{lstlisting} \vspace{5mm}

\textbf{Warning} : A default argument is evaluated only once time when the function is called for the first time. When you repeat function calls, it may cause problems especially with mutable arguments like lists. If your default argument is an empty list, it will create this empty list one time and reuse it for next calls. The way to counter this problem is to put an immutable argument and then create the list inside the function. \\
Here is an exemple : 
\begin{lstlisting}[language=Python]
def add_employee(emp, emp_list = []):
    emp_list.append(emp)
    print(emp_list) # Not good because emp_list is mutable and is reused each time this function is called.
\end{lstlisting} \vspace{5mm}
Will become :
\begin{lstlisting}[language=Python]
def add_employee(emp, emp_list = None):
    if emp_list is None:
        emp_list = []
    emp_list.append(emp)
    print(emp_list) # Good because emp_list is immutable and is new each time this function is called.
\end{lstlisting} \vspace{5mm}


\subsection{Map function}
Map function is a special function used to apply a function for each element of a container. \textbf{map(function\_to\_apply, list)}
\begin{lstlisting}[language=Python]
liste = [1,2,3]
def map_function(x):
	return x**x
mapped_list = list(map(map_function,liste)) #No () for argument function

# before : [1, 2, 3] and now : [1, 4, 27]
\end{lstlisting} \vspace{5mm}

There is a way more effective way of doing it with \hyperref[Comprehension]{comprehension}.

\subsection{Filter function}
Filter function is a special function used to apply a selection for each element of a container. \textbf{map(function\_to\_apply, list)}
\begin{lstlisting}[language=Python]
liste = [1,2,3]
def filter_function(x):
	return x%2!=0
filtered_list = list(filter(filter_function,liste))

# before : [1, 2, 3] and now : [1, 3]
\end{lstlisting} \vspace{5mm}

There is a way more effective way of doing it with \hyperref[Comprehension]{comprehension}.

\subsection{Unknown parameters}
Sometimes you don't know how many arguments a function is going to receive. Also, it's important to handle unknown parameters. \textit{It's the case for exemple with the print() function}. \textbf{* means unnamed parameters and ** means named parameters}
\begin{lstlisting}[language=Python]
def parameters(*args, **kwargs):
	print(f"I received these unnamed args : {args}")
	print(f"I received these named args : {kwargs}")
parameters(1,"azerty",[1,2], couleur="rouge", taille_en_cm=172)
both
# I received these unnamed args : (1, 'azerty', [1, 2])
# I received these named args : {'couleur': 'rouge', 'taille_en_cm': 172}
\end{lstlisting} \vspace{5mm}

\newpage
\section{Class}
\label{sec:Class}
Classes are a way of bringing together data and functionality. Creating a new class creates a new type of object and so new instances of this type can be built.\newline

\subsection{Instance}
Each instance can have its own attributes, which defines its state. An instance can also have methods (defined by the instance class) to modify its state.
\begin{lstlisting}[language=Python]
class MyClass(object):
	def __init__(self):
		pass

my_instance = MyClass()
\end{lstlisting} \vspace{5mm}

\subsection{Methods}
Methods are functions that bellow to the class. A method can be used by the instance as follow  : \textbf{my\_instance.my\_method()}
\begin{lstlisting}[language=Python]
class MyClass(object):
	def __init__(self):
		pass
	def my_first_method(self):
	    print("hello")
	def my_second_method(self):
	    print("world")

my_instance = MyClass()
my_instance.my_second_method()
\end{lstlisting} \vspace{5mm}

\subsection{Class variable}
Class variables are useful in some cases. Imagine a variable that would always be used in the class and that the class always access. They are variables that the instance don't necessarily need.
\begin{lstlisting}[language=Python]
class ClassVariables(object):
	nb_instance = 0
	pourcentage = 1.1

	def __init__(self, price):
		self.price = price
		ClassVariables.nb_instance += 1

	def raise_price(self):
		self.price = round(self.price * self.pourcentage,2)

a = ClassVariables(100)
a.raise_price()
print(a.price) # 110.0
print(ClassVariables.nb_instance) # 1
\end{lstlisting} \vspace{5mm}
In this code, nb\_instance and pourcentage are my class variables, I access to them with ClassVariables.nb\_instance and self.pourcentage. I choose to write it like that so that I can possibly the pourcentage for each instance later but I won't be able to affect nb\_instance because it bellows to the class.

\subsection{Inheritance}
Inheritance is a concept of relation between classes. Some are parents, the other are children. A children inherit from every methods from the parent class but can overload them. A child class can have multiple parents. \\
Here is a useful example : a parent class that automatically initialize the childs :
\begin{lstlisting}[language=Python]
class Initializer:
    def __init__(self, *args, **kwargs):
        if kwargs and not args:
            print(f"kwargs is not empty : {kwargs}")
            for key, value in kwargs.items():
                setattr(self, key, value)
        else:
            raise ValueError("You didn't enter the correct arguments")
 
 
class MyClass(Initializer):
    def __str__(self):
        return f"I'm {self.__class__.__name__} and here are my attributes : {self.__dict__}"
 
 
my_instance = MyClass(a=1, b=2)
\end{lstlisting} \vspace{5mm}

Here is another example with multiple inheritance
\begin{lstlisting}[language=Python]
class Dog(object):
	def __init__(self, age):
		self.age = age
	def speak(self):
		print("Waf")
class Cat(Dog, Animal): #multiple inheritance : Cat have some attributs from Dog but is also an Animal
	def __init__(self, age, nom):
		super().__init__(age)
		self.nom = nom
	def speak(self):
		print("Miaou")
\end{lstlisting} \vspace{5mm}

\subsection{Dunder methods}
Dunder methods are specific function from a class, they are surrounded by \_\_. A dunder method can be used by the instance as follow :\\ \textbf{my\_instance.\_\_dunder\_method\_\_}
\begin{lstlisting}[language=Python]
class Point(object):
	def __init__(self, x=0,y=0):
		self.x = x
		self.y = y
		self.conteneur = [1,2,3,4,5,6,7]

	def __str__(self):
		print("I'm the class Point")

	def __add__(self, p):
		"""la fonction add surcharge l'operateur +"""
		return Point(self.x + p.x, self.y + p.y)

#	def __getattr__(self, name):
#		print(f"{name} didn't found")

	def __setattr__(self, name, value):
		"""On modifie la classe mere directement plutot que seulement appeler setaatr de cette classe et tourner en boucle sur la meme methode"""
		object.__setattr__(self, name, value) #Chaque classe cree herite de base de la classe object

	def __delattr__(self, name):
		print(f"Deleting {name} ...")

	def __getitem__(self, index):
		return self.conteneur[index]

	def __setitem__(self, index, value):
		self.conteneur[index] = value

	def __contains__(self, value): # 8 in ma_liste  <==>  ma_liste.__contains__(8)
		return True if value in self.conteneur else False

	def __len__(self):
		return len(self.conteneur)

	"""Autres surcharges : 

	__sub__(self,p) : -
	__mul__(self,p) : *
	__truediv__(self, p) : /
	__floordiv__(self, p) : //
	__mod__(self, p) : %
	__pow__(self, p) : **

	__gt__(self,p)  : >
	__ge__(self,p) 	: >=
	__lt__(self,p)  : <
	__le__(self,p)  : <=
	__eq__(self,p) : == 

	__iadd__(self,p) : +=
	__isub__(self,p) : -=
	__imul__(self,p) : *=
	__itruediv__(self, p) : /=	
	...
	"""
\end{lstlisting} \vspace{5mm}

\subsection{Static and class methods}
Static methods have a link with the class but don't use any attribute from it. There is no \textbf{self} in the parameters. \\
Class methods concerns class variables. There is no \textbf{self} in the parameters but \textbf{cls}.
\begin{lstlisting}[language=Python]
class StaticClass:
	nb_class=0
	def __init__(self):
		print("une nouvelle classe vient d'etre creee")
		nb_class+=1
	
	@classmethod
	def ma_func(cls): #pas de self, obligatoirement cls
		"""Agit avec les variables de la classe"""
		return cls.nb_class

	@staticmethod
	def ma_func2(arg1, arg2):#pas de self
		"""N'agit pas avec les composants de la classe mais est quand meme en lien avec la classe"""
		return arg1 + arg2
\end{lstlisting} \vspace{5mm}

\subsection{Property}
Property concerns the private and public aspect from a class even though everything is public in python. In python, a variable or method which start with \_ is considered as "private". Also, we need to create getters and setters to access and modify these privates elements. Property redirect calls of privates elements to these getters and setters.
\begin{lstlisting}[language=Python]
"""
Property : permet d'offrir des accesseurs et mutateurs pour definir un attribut prive

La methode donnant acces a l'attribut

La methode modifiant l'attribut

La methode appelee quand on souhaite supprimer l'attribut (optionnel)

La methode appelee quand on demande de l'aide sur l'attribut (optionnel)

"""
class Test(object):
	def __init__(self, x=0, y=0):
		self.x = x
		self.y = y
		self._dimension = 2 #Attribut prive

	def _get_dimension(self):
		return self._dimension

	def _set_dimension(self,value):
		self._dimension = value
		
	dimension = property(_get_dimension, _set_dimension) # lorsqu'on appelera objet.dimension, property redirigera vers les accesseurs/mutateurs prives
\end{lstlisting} \vspace{5mm}

There is another way of doing it in a more readable and better way with \hyperref[subsec:Property]{property decorator}.

\subsection{Metaclass}
Every class inherit from the \textit{object} class, metaclass is a way to define how to create our own classes without inheriting from \textit{object}.

\subsection{Other}
In python, everything is public so there isn't any private method or variable from a class. We can use \_ to tell to the user that we want it private even though it's not really.

In classes you can use self.\_\_my\_private\_attr = "I'm private" 
It's called name scrambling and it is used to ensure that subclasses don't accidentally override the private methods and attributes of their superclasses. It's not designed to prevent deliberate access from outside. We can see it with : my\_instance.\_\_dict\_\_

There are some tips useful to know concerning class :
\begin{lstlisting}[language=Python]
print(dir(ma_instance)) #return a list of every dunder methods, methods and attributes from the class.
print(ma_instance.__dict__) # return a dict with attributes as keys and their value. associated.
print(issubclass(child_class, parent_class)) # return True if child_class is the child of parent_class.
print(isinstance(my_instance, my_class)) # return True if my_instance is an instance from my_class.
\end{lstlisting} \vspace{5mm}

\newpage
\section{Decorators}
A decorator is a design pattern in Python that allows a user to add new functionality to an existing object without modifying its structure. Decorators are usually called before the definition of a function you want to decorate. \textbf{@my\_decorator}\newline

\subsection{Function decorator}

\subsubsection{With a function as decorator}
A decorator can be a function applied to wrap another function and apply a process on it each time it's called.
\begin{lstlisting}[language=Python]
import time
def timer(func):
	def wrapper(*args, **kwargs):
		start = time.time()
		rv = func(*args, **kwargs)
		total = time.time() - start
		print("Time to execute : "+ str(total))
		return rv
	return wrapper

@timer #we can chain decorators
def exemple(x):
	return "je suis "+str(x)
	
rv = exemple(5)
#Time to execute : 2.384185791015625e-06
print(rv) #je suis 5
\end{lstlisting} \vspace{5mm}

\subsubsection{With a class as decorator}
A decorator can also be a class applied to wrap a function and apply a process on it each time it's called.

Last code become :
\begin{lstlisting}[language=Python]
import time
class timer(object):
    def __init__(self, func):
        self.func = func
    def __call__(self, *args, **kwargs):
        start = time.time()
		rv = self.func(*args, **kwargs)
		total = time.time() - start
		print("Time to execute : "+ str(total))
		return rv

@timer #we can chain decorators
def exemple(x):
	return "je suis "+str(x)
	
exemple(5)
#Time to execute : 2.384185791015625e-06
print(rv) #je suis 5
\end{lstlisting} \vspace{5mm}

\subsection{Class decorator}
Classes can also be decorated the same way that we do with function.\\
Here is an useful example of a class that automatically initialize another class :
\begin{lstlisting}[language=Python]
class ClassInitializer:
    def __init__(self, cls):
        print("Entering __init__ ...")
        self.cls = cls
 
    def __call__(self, *args, **kwargs):
        print("Entering __call__ ...")
        obj = self.cls() # create an instance
 
        if kwargs and not args:
            print(f"kwargs is not empty : {kwargs}")
            for key, value in kwargs.items():
                setattr(obj, key, value) # set attributes to the new instance
        else:
            raise ValueError("You didn't enter the correct arguments")
        return obj
 
 
@ClassInitializer
class MyClass:
    def __str__(self):
        return f"I'm {self.__class__.__name__} and here are my attributes : {self.__dict__}"
 
 
my_instance = MyClass(a=1, b=2)
\end{lstlisting} \vspace{5mm}

\subsection{Multiple decorators}
You can chain decorators to apply multiple processes on the same function / class. \\
Sometimes multiple decorators create conflicts between each other by manipulating the original function. You can fix this easily with the module \textbf{functools}. You need to add a \textbf{wraps(my\_func)} decorator on each wrapper function inside your decorators.\\

The function code become :
\begin{lstlisting}[language=Python]
import time
from functools import wraps
def timer(func):
    @wraps(func) #changement
	def wrapper(*args, **kwargs):
		start = time.time()
		rv = func(*args, **kwargs)
		total = time.time() - start
		print("Time to execute : "+ str(total))
		return rv
	return wrapper

#possibly another decorators here
@timer
def exemple(x):
	return "je suis "+str(x)
	
rv = exemple(5)
#Time to execute : 2.384185791015625e-06
print(rv) #je suis 5
\end{lstlisting} \vspace{5mm}

\subsection{Property decorator}
\label{subsec:Property}
Property decorator are one of the most useful decorator in classes to manage getters, setters and deleters. \textbf{@my\_method.getter/setter/deleter}\\
Indeed, when you use a variable that use some attributes and then you set later one of thes attributes, it won't change in your variable which use attributes. \\
The way to manage it is by using property decorator into methods as attributes that replace the previous variable. \\
For example :
\begin{lstlisting}[language=Python]
class Myclass(object):
	def __init__(self, first, last):
		self.first = first
		self.last = last
		self.email = self.first + '.' + self.last + "@gmail.com"

	def fullname(self):
		return f"{self.first} {self.last}"
		
p1 = Myclass("Ewan", "Carree")
p1.first = "Lou-Anne"

print(p1.email) # Ewan.Carree@gmail.com -- first didn't change
print(p1.fullname()) # Lou-Anne Carree
\end{lstlisting} \vspace{5mm}
Will become :
\begin{lstlisting}[language=Python]
class Myclass(object):
	def __init__(self, first, last):
		self.first = first
		self.last = last

	@property
	def email(self):
		 return self.first + '.' + self.last + "@gmail.com"

	@property
	def fullname(self):
		pass#return f"{self.first} {self.last}"

	@fullname.setter
	def fullname(self, name):
		first,last = name.split(' ')
		self.first = first
		self.last = last

	@fullname.getter
	def fullname(self):
		return f"{self.first} {self.last}"

	@fullname.deleter
	def fullname(self):
		print("deleting ...")
		self.first = None
		self.last = None

p1 = Myclass("Ewan", "Carree")
p1.fullname = "Lou-Anne Le_Bras"

print(p1.email) # Lou-Anne.Le_Bras@gmail.com
print(p1.fullname) # Lou-Anne Le_Bras
\end{lstlisting} \vspace{5mm}

\subsection{Decorator with argument(s)}
Sometimes you need to pass argument(s) into you decorator to modify the your decorator is working. To solve that problem, you need to nest your previous decorator into un new function. \\
Here is an exemple : \\
\begin{lstlisting}[language=Python]
import time
def add_prefix(prefix): #every function nested have access to that prefix : enclosing
    def timer(func):
    	def wrapper(*args, **kwargs):
    		start = time.time()
    		rv = func(*args, **kwargs)
    		total = time.time() - start
    		print(prefix + "Time to execute : "+ str(total))
    		return rv
    	return wrapper
    return timer

@add_prefix("exemple : ")
def exemple(x):
	return "je suis "+str(x)
	
rv = exemple(5)
# exemple : Time to execute : 2.384185791015625e-06
print(rv) #je suis 5
\end{lstlisting} \vspace{5mm}

\newpage
\section{Generators}
\label{sec:Generators}
Generators are simple and powerful tools for creating iterators. They are written like regular functions but use the yield statement when they want to return data. Each time it is called by next(), the generator resumes execution where it left off (keeping all of its execution context).\newline
\subsection{Iterators}
\subsection{Yield}

\newpage
\section{Modules}
Modules are Python programs that contain functions that we often reuse (we also call them libraries or libraries). These are “toolboxes” that will be very useful to you.\newline

\subsection{Import}
\label{subsec:Import}

\subsubsection{Import module as}
Sometimes you import modules but it's very long to write methods from a long module name. Plus, it's not good to use the \textit{import * from module} because it can creates conflicts between function and class that have the same name in two different modules. Rather than writing module.class you can use the key word \textbf{as}. It very used for libraries like numpy as np, matplotlib.pyplot as plt and scipy.signal as sig
\label{As}

\subsection{Time}
\subsubsection{Time}
For further explanations, see the \href{https://docs.python.org/3/library/time.html}{official documentation}

\subsubsection{Datetime}
For further explanations, see the \href{https://docs.python.org/3/library/datetime.html}{official documentation}

\subsection{Password}

\subsubsection{Getpass}
Get pass is a very useful module to enter password secretly. In deed, it doesn't show the characters entered.
\begin{lstlisting}[language=Python]
mdp getpass.getpass("Type your password : ")
\end{lstlisting} \vspace{5mm}

For further explanations, see the \href{https://docs.python.org/3/library/getpass.html}{official documentation}

\subsubsection{Hashlib}
You can secure you password get from getpass by hashing them into different hash algorithm.\\
To see every hash algorithms you can type this command : 
\begin{lstlisting}[language=Python]
hashlib.algorithms_guaranteed
\end{lstlisting} \vspace{5mm}
First, you are going to encode your password into bytes. Then, use the hash algorithm.
\begin{lstlisting}[language=Python]
mot_de_passe = hashlib.sha1(b"mot de passe")
\end{lstlisting} \vspace{5mm}
Finally, you'll need to transform your hashed password into bytes or string. String is more readable and reusable.
\begin{lstlisting}[language=Python]
mot_de_passe.hexdigest()
\end{lstlisting} \vspace{5mm}
Then you can save this password and compare it to the password entered by the user to see if it corresponds.



For further explanations, see the \href{https://docs.python.org/3/library/hashlib.html}{official documentation}


\subsection{Os}
\subsubsection{Working repertory}
You can get you actual working repertory by using :
\begin{lstlisting}[language=Python]
my_repertory = os.getcwd()
\end{lstlisting} \vspace{5mm}

\subsubsection{Terminal commandline}
You can run terminal commandlines by using : (look out for commands that corresponds with the os terminal you are running you program in)
\begin{lstlisting}[language=Python]
os.system("ls")

#get the value returned with
cmd = os.popen("ls")
cmd.read()
\end{lstlisting} \vspace{5mm}

\subsection{Sys}
\subsubsection{Import module from another repertory}
Sometimes you need to import a module that isn't into you actual repertory, rather than copy this module into you repertory you can import it by another way. \\

Tree exemple : \\
Main/ \\
....main.py \\
....Test/ \\
........test.py \\

\begin{lstlisting}[language=Python]
import sys
sys.path.append("./Test")
import test # .py file (module)
\end{lstlisting} \vspace{5mm}

Another way to do this in a more effective way is to set \hyperref[subsec:PathVariables]{path variables}.

\subsubsection{Memory used by a variable}
Control you memory while programming. 
\begin{lstlisting}[language=Python]
var = [1]*100
print(f"memoire utilisee par var : {sys.getsizeof(var)} bytes") #memoire utilisee par var : 856 bytes
\end{lstlisting} \vspace{5mm}

\subsubsection{Redirect flow}
We can redirect the flow to write directly somewhere instead of the terminal.
\begin{lstlisting}[language=Python]
file = open("output.txt", 'w')
sys.stdout = fichier # return to original flow with sys.__stdout__
\end{lstlisting} \vspace{5mm}

\subsubsection{Exit program}
You can exit the program any time you want when it's running. The parameter inside the function is important to specify to the user is there has been a problem or not; 0 means no problem and anything else (often 1) means that there has been a problem.
\begin{lstlisting}[language=Python]
sys.exit(parameter)
\end{lstlisting} \vspace{5mm}

\subsubsection{Get parameters passed in the call}
You can get any parameter specified by the user when he runned the program. (if an parameter is separated by space(s), sourround him by "").
\begin{lstlisting}[language=Python]
sys.argv
\end{lstlisting} \vspace{5mm}

\subsection{Math}
For further explanations, see the \href{https://docs.python.org/3/library/math.html}{official documentation}

\subsection{Random}
For further explanations, see the \href{https://docs.python.org/3/library/random.html}{official documentation}

\subsection{Argparse}
You can parse argument(s) passed in the call of program using argparse.
\begin{lstlisting}[language=Python]
parser = argparse.ArgumentParser()

#add instruction when user type program.py --help/-h
#imagine we need an compulsory argument of type int :
parser.add_argument("x", type=int, help="description of x")
#imagine that the user can specify an other optional argument:
parser.add_argument("-v", "--verbose", action="store_true", help="add more explanation")

#save arguments
args = parser.parse_args()

#get args
print(args.x)
if args.verbose:
    print("I add more explanations")
\end{lstlisting} \vspace{5mm}
For further explanations, see \href{http://www.sharelatex.com}{argparse tutorial} or  \href{https://docs.python.org/3/library/argparse.html}{official documentation}.


\subsection{Unittest}
In every program it's very useful to test every functionnality that we propose. Unittest is a powerful module to test our code. You have to create another module starting with "test" into the same repertory from your main program.

Here is an exemple of hos to use this module :
\begin{lstlisting}[language=Python]
import random
import unittest

class RandomTest(unittest.TestCase):

    """Test case utilise pour tester les fonctions du module 'random'."""

    def setUp(self):
        """Initialisation des tests."""
        self.liste = list(range(10))

    def test_choice(self):
        """Test le fonctionnement de la fonction 'random.choice'."""
        elt = random.choice(self.liste)
        self.assertIn(elt, self.liste)

    def test_shuffle(self):
        """Test le fonctionnement de la fonction 'random.shuffle'."""
        random.shuffle(self.liste)
        self.liste.sort()
        self.assertEqual(self.liste, list(range(10)))

    def test_sample(self):
        """Test le fonctionnement de la fonction 'random.sample'."""
        extrait = random.sample(self.liste, 5)
        for element in extrait:
            self.assertIn(element, self.liste)

        with self.assertRaises(ValueError):
            random.sample(self.liste, 20)
\end{lstlisting} \vspace{5mm}
def setUp(self) is similar to def \_\_init\_\_(self), that's where you define generalities.
Then create a function for each functionnality, it must correspond with the right assertion method.

Here are every assertion methods you can use to test your functionnalities.
\begin{table}[h]
\begin{center}
{\renewcommand{\arraystretch}{1} %donne la distance entre les lignes%
{\setlength{\tabcolsep}{0.5cm} %donne la distance entre les collones%
\begin{tabular}{|c|c|}
  \hline
  assertEqual(a, b) & a == b \\
  \hline
  assertNotEqual(a, b) & a != b \\
  \hline
  assertTrue(x) & x is True \\
  \hline
  assertFalse(x) & x is False \\
  \hline
  assertIs(a, b) & a is b \\
  \hline
  assertIsNot(a, b) & a is not b \\
  \hline
  assertIsNone(x) & x is None \\
  \hline
  assertIsNotNone(x) & x is not None \\
  \hline
  assertIn(a, b) & a in b \\
  \hline
  assertNotIn(a, b) & a not in b \\
  \hline
  assertIsInstance(a, b) & isinstance(a, b) \\
  \hline
  assertNotIsInstance(a, b) & not isinstance(a, b) \\
  \hline
  assertRaises(exception, fonction, *args, **kwargs) & \makecell{check if function \\ raise the good exception}  \\
  \hline
\end{tabular}}}
\end{center}
\caption{Assertion methods}
\end{table}

After creating this module, you can test it by two different ways. The first one is \textbf{unittest.main()} but the other one is much more convenient. Go into the repertory into a terminal where you project and test file are stored and type the command \textbf{pythonX -m unittest}. It will run automatically each test.

For further explanations, see the \href{https://docs.python.org/3/library/unittest.html}{official documentation}


\subsection{Re}
Regex also known as regular expression is a very powerfull module for searching in string. \textbf{re.search(expression, string)} with \textbf{expression = r"..."} \\

\begin{table}[h]
\begin{center}
{\renewcommand{\arraystretch}{2} %donne la distance entre les lignes%
{\setlength{\tabcolsep}{1.5cm} %donne la distance entre les collones%
\begin{tabular}{|l|c|r|}
  \hline
  \makecell{$\land$ \\ start} & \makecell{* \\ 0,1,...} & \makecell{\{\} \\ n times} \\
  \hline
  \makecell{\$ \\ end} & \makecell{+ \\ 1,...} & \makecell{[] \\ sth inside} \\
  \hline
  \makecell{? \\ 0 or 1} & \makecell{() \\ group} &  \\
  \hline
\end{tabular}}}
\end{center}
\caption{Regex methods}
\end{table}

Example :
\begin{lstlisting}[language=Python]
# I want to find a phone number with digits separated by a space, a point or an hyphen.
expression = r"^0[0-9]([ .-]?[0-9]{2}){4}$"
# I want a password with at least 6 characters and containing number or letter or both.
expression = r"^[A-Za-z0-9]"
\end{lstlisting} \vspace{5mm}

See more explanation about re on the \href{https://docs.python.org/3/library/re.html?highlight=re#module-re}{official documentation}

\subsection{Cx\_freeze / setup}
You can create .exe program that anybody can run on its own computer without having python or the extern libraries installed by using the module cx\_Freeze. \\
You can do the same by creating a setup.py file. \\

See more explanation about cx\_Freeze on the  \href{https://cx-freeze.readthedocs.io/en/latest/}{official documentation}


\subsection{Network}
With network you can exchange data between a client and a server following the TCP protocol. To establish a connexion between client and server, you need an host name and a port number. \\
Here is an exemple of client and server : \\ \\
Server side
\begin{lstlisting}[language=Python]
import socket
import select

hote = ''
port = 12800

connexion_principale = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
connexion_principale.bind((hote, port))
connexion_principale.listen(5)
print("Le serveur ecoute a present sur le port {}".format(port))

serveur_lance = True
clients_connectes = []
while serveur_lance:
    # On va verifier que de nouveaux clients ne demandent pas a se connecter
    # Pour cela, on ecoute la connexion_principale en lecture
    # On attend maximum 50ms
    connexions_demandees, wlist, xlist = select.select([connexion_principale],
        [], [], 0.05)
    
    for connexion in connexions_demandees:
        connexion_avec_client, infos_connexion = connexion.accept()
        # On ajoute le socket connecte a la liste des clients
        clients_connectes.append(connexion_avec_client)
    
    # Maintenant, on ecoute la liste des clients connectes
    # Les clients renvoyes par select sont ceux devant etre lus (recv)
    # On attend la encore 50ms maximum
    # On enferme l'appel a select.select dans un bloc try
    # En effet, si la liste de clients connectes est vide, une exception
    # Peut etre levee
    clients_a_lire = []
    try:
        clients_a_lire, wlist, xlist = select.select(clients_connectes,
                [], [], 0.05)
    except select.error:
        pass
    else:
        # On parcourt la liste des clients a lire
        for client in clients_a_lire:
            # Client est de type socket
            msg_recu = client.recv(1024)
            # Peut planter si le message contient des caracteres speciaux
            msg_recu = msg_recu.decode()
            print("Recu {}".format(msg_recu))
            client.send(b"5 / 5")
            if msg_recu == "fin":
                serveur_lance = False

print("Fermeture des connexions")
for client in clients_connectes:
    client.close()

connexion_principale.close()
\end{lstlisting} \vspace{5mm}
Client side :
\begin{lstlisting}[language=Python]
import socket

hote = "localhost" #car nous avons les deux serveurs sur la meme machine
port = 12800 #port du serveur qui ecoute

connexion_avec_serveur = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
connexion_avec_serveur.connect((hote, port))
print("Connexion etablie avec le serveur sur le port {}".format(port))

msg_a_envoyer = b""
while msg_a_envoyer != b"fin":
    msg_a_envoyer = input("> ")
    # Peut planter si vous tapez des caracteres speciaux
    msg_a_envoyer = msg_a_envoyer.encode()
    # On envoie le message
    connexion_avec_serveur.send(msg_a_envoyer)
    msg_recu = connexion_avec_serveur.recv(1024)
    print(msg_recu.decode()) # La encore, peut planter s'il y a des accents

print("Fermeture de la connexion")
connexion_avec_serveur.close()
\end{lstlisting} \vspace{5mm}

\subsubsection{Socket}
Sockets allow us to open a connexion between two or more computer. Ports available are included between 1024 and 65535. \\
For further explanations, see the \href{https://docs.python.org/3/library/socket.html}{official documentation} and socketserver  \href{https://docs.python.org/3/library/socketserver.html}{official documentation} 
\subsubsection{Select}
For further explanations, see the \href{https://docs.python.org/3/library/select.html}{official documentation}

\subsection{Threads}
Threading is an advanced module especially used to run multiple processes at the same time. Normally, each functin call follow each other in one way. But with threading you can run them simultaneously. It's especially useful when a call lasts a lot of time, with threading, you don't waste this time.

For further explanations, see the \href{https://docs.python.org/3/library/threading.html}{official documentation}


\subsection{Inspect}
If you're interested in knowing how a class is built you can use the inspect module. It prints out the full code from the class. You can't use this function on built-in module like math, os, ... because it's not written in python.
\begin{lstlisting}[language=Python]
import inspect
from queue import Queue
print(f"Code source : \n{inspect.getsource(Queue)}")
\end{lstlisting} \vspace{5mm}

\subsection{Operator}

\newpage
\section{Toolbox}
\subsection{Break / Continue / Pass / Return}
\label{subsec:BCPR}
\begin{lstlisting}[language=Python]
#pass is similar to an empty instruction.
if True:
    pass

#return is used in function to give a response to a call.
def func():
	"""this is a docstring, use help(func) to know more about this function."""
	return "j'ai retourne une phrase"

#break and continue are used in loop to modify the way the loop is looping.
nb = 3
while nb != 20:
	if nb>6:
		break #End the loop
	nb+=1
	if nb==5:
		continue #Go to the top of the loop without executing the rest.	
	print(nb)

#4
#6
#7
\end{lstlisting} \vspace{5mm}

\subsection{Context manager}
\label{subsec:ContextManager}

\subsection{Global/Nonlocal variables}
\label{subsec:Global/Nonlocal}
Variables that are created outside of a function (as in all of the examples above) are known as global variables.\\
Global variables can be used by everyone, both inside of functions and outside.
\begin{lstlisting}[language=Python]
a = b = 5
#a = 5 et b = 5
def modify(b):
	global a #modify the variable outside the function
	a*=2
	b*=2

modify(b)
#a = 10 et b = 5
\end{lstlisting} \vspace{5mm}

\subsection{Exception}
In python you can handle exceptions that may occur when your program is running. \textit{We can always use \textbf{except Exception as e} but it's better to be the most precise possible.}
\subsubsection{Try / Except / Else / Finally}
This is the basic structure to handle exception :
\label{TEEF}
\begin{lstlisting}[language=Python]
nom = "Jerome"
try:
	key = int(nom)
except ValueError:
	print("Votre nom ne peut pas etre convertit en integer")
else: #done if try is ok
	print("Key as been validated")
finally: #always done
	print("end ...")
	
#Votre nom ne peut pas etre convertit en integer
#end ...
\end{lstlisting} \vspace{5mm}

We can also create our own exception by creating a new class.
\begin{lstlisting}[language=Python]
#Creer notre propre exception : La methode __str__ de la classe est ce qui est appele pour afficher le message d'erreur
class MonException(Exception):
    """Exception levee dans un certain contexte qui reste a definir"""
    def __init__(self, message):
        """On se contente de stocker le message d'erreur"""
        self.message = message
    def __str__(self):
        """On renvoie le message"""
        return self.message
\end{lstlisting} \vspace{5mm}

\subsubsection{Raise}
\label{Raise}
If you want to personalize the way a process handle exceptions you can use the \textbf{raise} keyword.


\subsubsection{If / Elif / Else}
\label{IEE}
You can write if / else conditions in an easy way in python :
\begin{lstlisting}[language=Python]
condition = False

#Bad way :
if condition:
	x=1
else:
	x=0
	#0

#Good way :
x = 1 if condition else 0
#0
\end{lstlisting} \vspace{5mm}

\subsection{Files}

\subsection{// and **}
There are two basics operations in python very useful instead of using a math method.
\begin{lstlisting}[language=Python]
print(f"10 / 3 = {10 / 3}") # 10 / 3 = 3.3333333333333335
print(f"10 // 3 = {10 // 3}") # 10 // 3 = 3

print(f"3**3 = {3**3}"}) # 3**3 = 9
\end{lstlisting} \vspace{5mm}

\subsection{Assertion}
\label{subsec:Assertion}
You can verify a condition before parsing an information by checking the instance type.
\begin{lstlisting}[language=Python]
b = 3
assert isinstance(b, int)
\end{lstlisting} \vspace{5mm}

\subsection{Cast}
Sometimes you need to convert a variable from a certain type to another. Cast is a good way to do it but you've to know that you can lose information by doing it. \\ \\
You can do it by simply follow this pattern : \textbf{new\_type(my\_variable)}
Notice that you have to be coherent in your type transformation. For example, you won't be able to cast a string into an integer if your string = "Salut".

\subsection{Encoding}
You can precise in the first line of your .py document the encoding your are curently using.
\begin{lstlisting}[language=Python]
# -*-coding:Utf-8 -*
\end{lstlisting} \vspace{5mm}

\subsection{Path}
You can precise path to your python compilator in the second line of your .py document.
\begin{lstlisting}[language=Python]
# !/usr/bin/python3.8
\end{lstlisting} \vspace{5mm}

\subsection{Test the validity of several values}
You can check if one of several values is not False.
\begin{lstlisting}[language=Python]
x,y,z = 0,1,0
if 1 in (x,y,z):
    pass
if x or y or z:
    pass
if any((x,y,z)):
    pass
\end{lstlisting} \vspace{5mm}

\subsection{Encoding}
It's possible to encode a string into bytes using a special string methods. You have to put a b for bytes in front of the first " of you string. Another way is to use encode function as my\_string.encode()

\subsection{F-string}
\label{subsec:F-string}
There is a simple way to write argument in you print() function. It's called F-string. A lot of methods come with it. \textbf{print(f"blabla \{my\_argument\} blabla")}
\begin{lstlisting}[language=Python]
for n in range(2):
	print(f"n = {n:03}")
#n = 000
#n = 001

pi = 3.141592
print(f"pi = {pi:.2f}") 
# pi = 3.14
\end{lstlisting} \vspace{5mm}

You can see more methods by looking specifically on every module you want, for example datetime f-string.

\subsection{Else clause on loop}
Else can be used in many case like in the structure if/elif/else ofently. But we can also use it in loops like for or while. It is similar to the finally statement of try/except. \\
It is always runned except if the loop encounter the \textbf{break} keyword.

\begin{lstlisting}[language=Python]
for i in range(2):
    print(i)
else: @doesn't encounter break
    print("Loop finished")
#0
#1
#Loop finished

i=0
while i<5:
    print(i)
    i+=1
    if i == 3:
        break
else: #encounter break before end
    print("Loop finished")
#0
#1
#2
\end{lstlisting} \vspace{5mm}

\subsection{Path Variables}
\label{subsec:PathVariables}

\subsection{Is vs ==}
\label{subsec:Is}
We can think that \textbf{is} and \textbf{==} are exactly the same but it's not the case. \textbf{==} is based on the fact that two objects' elements are exactly the same. Instead, \textbf{is} compare if the two objects belong to the same memory adress.\\
\textbf{is} cans be seen as \textbf{id(obj1) == id(obj2)} if we want to compare it to \textbf{==}.

Here is an example :
\begin{lstlisting}[language=Python]
list1 = [1,2,3,4]
list2 = [1,2,3,4]

list1 == list2 #True
list1 is list2 #False

list1 = [1,2,3,4]
list2 = list1

list1 == list2 #True
list1 is list2 #True
\end{lstlisting} \vspace{5mm}

\end{document}
